<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hi! Here's Sublime's House]]></title>
    <url>%2Farchives%2F72fc82f1.html</url>
    <content type="text"><![CDATA[欢迎小可爱们来到我的小屋(oﾟ▽ﾟ)o 下面是建站记录….2019年5月初，开始有了写博客记录所学所得的想法 2019年5月中旬，连续摸爬滚打后，初步习得了相关前端知识… 2019年6月初，在货比三家后，选择了Hexo静态框架，跟随大流换上了大名鼎鼎的NexT主题，并放在了github上 2019年6月末，偶然的发现，叹服于Material-X主题的精美，推翻所有的重来，并加上了Valine和看板娘，进行了细节的优化 最后，感谢小可爱们多多支持我喔٩(๑>◡ { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[【站点搭建】CenOS 7环境下使用WordPress搭建电协官网--（1）基础配置]]></title>
    <url>%2Farchives%2F826b26c7.html</url>
    <content type="text"><![CDATA[因下学期电协招新及20周年纪念的需要，需要搭建一个官方网站。我们以WordPress为例，介绍从购买一个服务器开始，到安装博客程序以及最后细节优化及注意事项。 环境准备 一个阿里云或者腾讯云服务器 宝塔面板 CenOS 7+ 系统 LAMP/LNMP环境 WordPress安装包 远程连接工具Xshell和Xftp 购买并配置服务器对于大多数国内用户来说，我们可以选着阿里云或者腾讯云的服务器，这里以选择腾讯云服务器为例，进入腾讯云，注册并登录后进入管理后台。在云产品中选择云服务器： 之后，在云服务器里面选择创建： 选择适当的配置，我们可以选择快速配置，可以按照如下配置购买，其中推荐使用CentOS系统，相对来说较为稳定。 购买后，选择左边的SSH密钥，新建后并下载（如我命名为xshell） 返回实例页面，点击右侧更多->密码/密钥->加载密钥，选择之前创建的密钥后，将会强制关机以绑定密钥。 下载Xshell和Xftp并远程连接 Xshell下载地址 Xftp下载地址 配置Xshell以下载Xshell为例，进入官网后右边有免费授权页面，填写相关信息后，收到回复邮件，打开链接即可免费下载（Xftp同理） 下载并安装Xshell和Xftp后，点击文件->新建，在“连接”窗口，填写的主机为腾讯云服务器外网IP地址，在“用户身份验证”窗口，选择方法为“Public Key”,用户名为root，用户密钥选择之前下载的SSH密钥，点击连接即可成功连接至腾讯云服务器： 连接成功后的界面如下： 配置Xftp配置方法与Xshell类似，这里放上几张配置截图： 如果你已经实现了上述结果，恭喜你，远程连接已配置成功。 PS:使用Xshell需要涉及Linux命令相关的知识。如不是很了解，建议点击这里的传送门了解基本命令。 安装宝塔面板安装宝塔面板主要是为了方便后期维护的方便，使得服务器配置可视化同时加快配置效率。 宝塔面板官方网站 PS：安装宝塔面板时，一定要保证系统纯净，即服务器中没有安装其他的任何软件，否则可能会安装失败！！！ 放行出站入站端口在安装面板之前，需要放行特定的入站和出站端口号。回到腾讯云管理界面，选择安全组->新建： 然后下载规则配置文件： sg_input_rules.xlsx sg_output_rules.xlsx 点击导入规则，将规则配置文件添加到入站和出站规则中： 之后，点击关联实例->新增关联，将规则和服务器相互关联。 正式安装打开之前配置好的Xshell，对于CenOS 7+的系统，输入如下命令安装: 1yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh 出现提示信息，询问是否安装宝塔面板，输入y并回车： 耐心等待片刻后，出现如下界面，则安装成功。 其中，给出了登录名和密码，登录地址为http://你的IP或域名地址:8888/安全入口地址的格式。浏览器输入登录地址并登录。如出现如下后台界面，则安装成功！！！ 至此，服务器的基础配置已基本完成。建议到面板设置修改登录名和密码，便于记忆。 感谢你的耐心阅读呀(๑◡๑)，原创不易，收藏并评论一下呗~ 接下来，我们可以配置服务器和安装WordPress等后续操作啦~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>电协官网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工具分享】实用的图片上传工具--PicGo]]></title>
    <url>%2Farchives%2F5af88fad.html</url>
    <content type="text"><![CDATA[博客写多了，有了图片加载慢的问题。这里分享一个简单实用的图片上传工具——PicGo此工具可以一键上传图片，对于编写博客和网站来说很有帮助。 写在前面…刚开始学习网页前端和博客搭建的时候，自己按照网上的教程一步步地学习。但后来，总会遇到一个问题： 随着网页一步步地完善，图片也越来越多，图片的杂余，使得打开一个页面的时候，总会非常的缓慢（将大部分时间都花在了图片的加载上） 为什么会这样呢原来，随着图片的增多，服务器的压力就会加大，加载网页代码的同时，也会加载图片，然而图片常常很大（几百K到5M大小不等），会有一个很长的加载过程。 怎么改进呢后来，我了解到可以通过CDN的方式来减轻服务器的压力。 PS:何为CDN？CDN简单通俗地来说，就是通过外链的方式，将脚本、图片、视频等文件链接到自己的服务器，这样，将占用自己服务器资源的文件放在其他的服务器中，以达到网页加速的目的。 国内有很多CDN的提供商，例如阿里云、腾讯云、七牛云、又拍云（其中七牛云和又拍云提供定量的免费储存空间）。 开始，我使用的是七牛云的对象储存空间，七牛云有10G的免费空间,但是有一个不便却来了：我需要每次打开七牛的管理后台，手动上传之后，再把链接复制下来，引用到我的博客文章中。这样效率真的很低下，使得图片上传的不便。 偶然一次的发现——图床工具PS:何为图床？图床简单来讲就是图片托管和储存地，即前面所说的CDN提供商（他们既有CDN又有对象存储，即图床）。 PicGo软件下载链接：https://picgo.github.io/PicGo-Doc/zh/guide/Github: https://github.com/Molunerfinn/PicGo 在这里，我们可以选择SM.MS、腾讯云、微博、Github、七牛、Imgur、阿里云和又拍云多种方式上传。上传后，可以自动得到复制链接，粘贴到文章里面即可(oﾟ▽ﾟ)o 这里，强力推荐SM.MS，免费而且速度又快，真的是不二之选！！！！ 就到这里啦，下次更新ヾ(◍°∇°◍)ﾉﾞ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】2019电赛--OpenMV]]></title>
    <url>%2Farchives%2Ff10b0e1a.html</url>
    <content type="text"><![CDATA[第二年参加电赛了，今年来到测控无人机方向，主要记录一些OpenMV学习经历。再苦逼也要加油呀！！！ 之前，19年电赛视觉模块始终不明朗，直到最近才确定不能用树莓派。于是，一直研究OpenMV的我终于放心了。（哈哈哈这个当然是题外话，吐槽一下） 正题–OpenMVOpenMV是基于嵌入式STM32单片机的基础上，经过层层封装之后，运用microPython语法开发的模块。哈哈哈稍微介绍一下，小白们可以看看… 这是我们队用的OpenMV mini的板子： OpenMV寻找直角（或特定角度）由于电赛视觉模块寻迹的原因，可能会涉及无人机直角转弯的问题，通过查找网上资料，获得了如下Python代码,感觉有一定的参考价值： 通过这个程序，我发现可以调用calculate_angle(line1, line2)函数得出偏角值，调用calculate_intersection(line1, line2)函数得出当前x和y的坐标值(cross_x, cross_y)，这样，再通过串口将对应的数据帧发送给飞控，在飞控端再进行帧格式解析，得出对应的数据后，在进行飞机相应的姿态调整。 123456def calculate_angle(line1, line2): # 利用四边形的角公式， 计算出直线夹角 angle = (180 - abs(line1.theta() - line2.theta())) if angle > 90: angle = 180 - angle return angle 123456789101112131415def calculate_intersection(line1, line2): # 计算两条线的交点 a1 = line1.y2() - line1.y1() b1 = line1.x1() - line1.x2() c1 = line1.x2()*line1.y1() - line1.x1()*line1.y2() a2 = line2.y2() - line2.y1() b2 = line2.x1() - line2.x2() c2 = line2.x2() * line2.y1() - line2.x1()*line2.y2() if (a1 * b2 - a2 * b1) != 0 and (a2 * b1 - a1 * b2) != 0: cross_x = int((b1*c2-b2*c1)/(a1*b2-a2*b1)) cross_y = int((c1*a2-c2*a1)/(a1*b2-a2*b1)) return (cross_x, cross_y) return (-1, -1) 下面附上完整源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145# Find Lines Example## This example shows off how to find lines in the image. For each line object# found in the image a line object is returned which includes the line's rotation.# Note: Line detection is done by using the Hough Transform:# http://en.wikipedia.org/wiki/Hough_transform# Please read about it above for more information on what `theta` and `rho` are.# find_lines() finds infinite length lines. Use find_line_segments() to find non-infinite lines.enable_lens_corr = False # turn on for straighter lines...import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.GRAYSCALE) # grayscale is fastersensor.set_framesize(sensor.QQVGA)sensor.skip_frames(time = 2000)clock = time.clock()# min_degree = 0 # 直线最小角度# max_degree = 179 # 直线最大角度# 判断是否为直角的阈值right_angle_threshold = (70, 90)binary_threshold = [(0, 60)]forget_ratio = 0.8move_threshold = 5def calculate_angle(line1, line2): # 利用四边形的角公式， 计算出直线夹角 angle = (180 - abs(line1.theta() - line2.theta())) if angle > 90: angle = 180 - angle return angledef is_right_angle(line1, line2): global right_angle_threshold # 判断两个直线之间的夹角是否为直角 angle = calculate_angle(line1, line2) if angle >= right_angle_threshold[0] and angle = 2: (line1, line2) = find_verticle_lines(lines) if (line1 == None or line2 == None): # 没有垂直的直线 draw_cross_point(old_cross_x, old_cross_y) continue # 画线 # img.draw_line(line1.line(), color = (255, 0, 0)) # img.draw_line(line2.line(), color = (255, 0, 0)) # 计算交点 (cross_x, cross_y) = calculate_intersection(line1, line2) print("cross_x: %d, cross_y: %d"%(old_cross_x, old_cross_y)) if cross_x != -1 and cross_y != -1: if abs(cross_x - old_cross_x) < move_threshold and abs(cross_y - old_cross_y) < move_threshold: # 小于移动阈值， 不移动 pass else: old_cross_x = int(old_cross_x * (1 - forget_ratio) + cross_x * forget_ratio) old_cross_y = int(old_cross_y * (1 - forget_ratio) + cross_y * forget_ratio) draw_cross_point(old_cross_x, old_cross_y) print("FPS %f" % clock.fps())# About negative rho values:## A [theta+0:-rho] tuple is the same as [theta+180:+rho]. PS: 源代码链接http://makermare.com:60010/example/feature/right-angle-detection.html OpenMV识别特征信息（可以用于识别飞机起飞降落点）数字识别按照例程，好像可以使用方法img.find_number()： 1234567891011121314151617181920212223# LetNet Exampleimport sensor, image, timesensor.reset() # Reset and initialize the sensor.sensor.set_contrast(3)sensor.set_pixformat(sensor.GRAYSCALE) # Set pixel format to RGB565 (or GRAYSCALE)sensor.set_framesize(sensor.QVGA) # Set frame size to QVGA (320x240)sensor.set_windowing((28, 28))sensor.skip_frames(time = 2000) # Wait for settings take effect.sensor.set_auto_gain(False)sensor.set_auto_exposure(False)clock = time.clock() # Create a clock object to track the FPS.while(True): clock.tick() # Update the FPS clock. img = sensor.snapshot() # Take a picture and return the image. out = img.invert().find_number() if out[1] > 3.0: print(out[0]) #print(clock.fps()) # Note: OpenMV Cam runs about half as fast when connected # to the IDE. The FPS should increase once disconnected. PS: 来源于http://makermare.com:60010/example/feature/digital-recognition.html 好像因为新版本的固件不支持识别数字的方法img.find_number()了，我的是OpenMV 4,自己试了试好像会报错，不知道为啥，应该是官方文档说的这个原因： IDE报错：官方文档解释： 关键点识别无可奈何，好像暂时就只能使用寻找关键点的方法了.当需要识别特征信息的时候，可以使用官方自带的一个方法img.find_keypoints()，keypoints即关键点，当识别到物块的关键点后，保存到变量kpts2中，便可以进行匹配，即运用image.match_descriptor()方法，进行匹配度识别，若匹配到了，便可以在图像上画出特征点，运用方法img.draw_keypoints()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 利用特征点检测特定物体例程。# 向相机显示一个对象，然后运行该脚本。 一组关键点将被提取一次，然后# 在以下帧中进行跟踪。 如果您想要一组新的关键点，请重新运行该脚本。# 注意：请参阅文档以调整find_keypoints和match_keypoints。import sensor, time, image# Reset sensorsensor.reset()# Sensor settingssensor.set_contrast(3)sensor.set_gainceiling(16)sensor.set_framesize(sensor.VGA)sensor.set_windowing((320, 240))sensor.set_pixformat(sensor.GRAYSCALE)sensor.skip_frames(time = 2000)sensor.set_auto_gain(False, value=100)#画出特征点def draw_keypoints(img, kpts): if kpts: print(kpts) img.draw_keypoints(kpts) img = sensor.snapshot() time.sleep(1000)kpts1 = None#kpts1保存目标物体的特征，可以从文件导入特征，但是不建议这么做。#kpts1 = image.load_descriptor("/desc.orb")#img = sensor.snapshot()#draw_keypoints(img, kpts1)clock = time.clock()while (True): clock.tick() img = sensor.snapshot() if (kpts1 == None): #如果是刚开始运行程序，提取最开始的图像作为目标物体特征，kpts1保存目标物体的特征 #默认会匹配目标特征的多种比例大小，而不仅仅是保存目标特征时的大小，比模版匹配灵活。 # NOTE: By default find_keypoints returns multi-scale keypoints extracted from an image pyramid. kpts1 = img.find_keypoints(max_keypoints=150, threshold=10, scale_factor=1.2) #image.find_keypoints(roi=Auto, threshold=20, normalized=False, scale_factor=1.5, max_keypoints=100, corner_detector=CORNER_AGAST) #roi表示识别的区域，是一个元组（x,y,w,h）,默认与framsesize大小一致。 #threshold是0~255的一个阈值，用来控制特征点检测的角点数量。用默认的AGAST特征点检测，这个阈值大概是20。用FAST特征点检测，这个阈值大概是60～80。阈值越低，获得的角点越多。 #normalized是一个布尔数值，默认是False，可以匹配目标特征的多种大小（比ncc模版匹配效果灵活）。如果设置为True，关闭特征点检测的多比例结果，仅匹配目标特征的一种大小（类似于模版匹配），但是运算速度会更快一些。 #scale_factor是一个大于1.0的浮点数。这个数值越高，检测速度越快，但是匹配准确率会下降。一般在1.35~1.5左右最佳。 #max_keypoints是一个物体可提取的特征点的最大数量。如果一个物体的特征点太多导致RAM内存爆掉，减小这个数值。 #corner_detector是特征点检测采取的算法，默认是AGAST算法。FAST算法会更快但是准确率会下降。 draw_keypoints(img, kpts1) #画出此时的目标特征 else: #当与最开始的目标特征进行匹配时，默认设置normalized=True，只匹配目标特征的一种大小。 # NOTE: When extracting keypoints to match the first descriptor, we use normalized=True to extract # keypoints from the first scale only, which will match one of the scales in the first descriptor. kpts2 = img.find_keypoints(max_keypoints=150, threshold=10, normalized=True) #如果检测到特征物体 if (kpts2): #匹配当前找到的特征和最初的目标特征的相似度 match = image.match_descriptor(kpts1, kpts2, threshold=85) #image.match_descriptor(descritor0, descriptor1, threshold=70, filter_outliers=False)。本函数返回kptmatch对象。 #threshold阈值设置匹配的准确度，用来过滤掉有歧义的匹配。这个值越小，准确度越高。阈值范围0～100，默认70 #filter_outliers默认关闭。 #match.count()是kpt1和kpt2的匹配的近似特征点数目。 #如果大于10，证明两个特征相似，匹配成功。 if (match.count()>10): # If we have at least n "good matches" # Draw bounding rectangle and cross. #在匹配到的目标特征中心画十字和矩形框。 img.draw_rectangle(match.rect()) img.draw_cross(match.cx(), match.cy(), size=10) #match.theta()是匹配到的特征物体相对目标物体的旋转角度。 print(kpts2, "matched:%d dt:%d"%(match.count(), match.theta())) #不建议draw_keypoints画出特征角点。 # NOTE: uncomment if you want to draw the keypoints #img.draw_keypoints(kpts2, size=KEYPOINTS_SIZE, matched=True) # Draw FPS #打印帧率。 img.draw_string(0, 0, "FPS:%.2f"%(clock.fps())) PS: 来源于星瞳科技例程https://book.openmv.cc/example/09-Feature-Detection/keypoints.html 这个例程还需要完善，运用到具体的OpenMV代码中需要将函数再次封装和修改。 OpenMV识别二维码（QR code）和条形码（Barcode）另附–我们组的飞机方案最近，我们组在紧张地准备电赛测控四旋翼无人机的题目，在准备过程中，我们购买了无名创新的TM4C123的飞控，正在研究源码和视觉模块的运用。无名创新的飞控是开源的，在B站上面有对应的讲解视频，涉及操作类和代码讲解类的视频，下面附上其网址： 无名科创开源飞控QQ群：540707961CSDN博客优酷ID：NamelessCotrun无名小哥B站教学视频淘宝店铺百度贴吧:无名科创开源飞控公司官网 我们组在学习的过程中，按照老师给的建议，决定采用外加一个TM4C123的控制板作为模拟的遥控器（即脱掉遥控器自主飞行降落），其中，无名的飞控是采用PPM信号编码和解码的方式，为了模仿遥控器的信号，我们参考了网上的一些文档，觉得十分有用： PPM原理和代码https://blog.csdn.net/Aaron_Suen/article/details/79416477https://blog.csdn.net/yibu_refresh/article/details/45752131 这几天我们队进度有点卡顿了，正在向两方面进展。我们准备了两个方案：使用之前所说的外置模拟遥控器的方式使用无名飞控自带的SDK模式进行二次开发 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>电赛</tag>
        <tag>OpenMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好鸭~]]></title>
    <url>%2Farchives%2Ff2d5fff6.html</url>
    <content type="text"><![CDATA[你好！这里是Sublime的个人小屋哦ヾ(◍°∇°◍)ﾉﾞ从今天起，我准备开始写博客啦~希望大家支持我呀^_^ 1printf("hello world, hello my blog!"); 1cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
</search>
