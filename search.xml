<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>友链迁移通知</title>
      <link href="archives/f7ef56eb.html"/>
      <url>archives/f7ef56eb.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn2.sublimerui.top/2021/01/05/699d161a910b3.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2021/01/05/699d161a910b3.png" srcset="data:image/png;base64,666" alt="banner"></p><a id="more"></a><p>本考研狗考研结束啦~</p><p>特前来更新维护博客了嘻嘻~</p><p>目前站点正在缓慢修改，有一些链接做了小的调整。</p><blockquote><p>其中，原友链页已经全部迁移至<a href="https://blog.moej.cn/links.html">https://blog.moej.cn/links.html</a>啦！当点击原友链按钮时，会自动跳转。</p></blockquote><blockquote><p>留言板也同样地迁移至新的地方：<a href="https://blog.moej.cn/inbox.html">https://blog.moej.cn/inbox.html</a></p></blockquote><blockquote><p>原生活站博客 &lt;blog.cwxyr.me&gt; 准备弃用，将在2周左右删除，所有数据已经迁移至新域名啦：<a href="https://blog.moej.cn/">https://blog.moej.cn/</a></p></blockquote><hr><p><strong>由于本人友链较多，逐一通知较为麻烦，也麻烦各位大佬看到以后更新一下嗷~</strong></p><p><strong>下面是我的新的友链链接：</strong></p><blockquote><p>名称： 果子酱<br>头像链接： <a href="https://cdn2.sublimerui.top/2021/01/03/5db7a51e823a6.ico">https://cdn2.sublimerui.top/2021/01/03/5db7a51e823a6.ico</a><br>博客地址： <a href="https://cwxyr.me/">https://cwxyr.me</a><br>站点描述： 业精于勤，荒于嬉，毁于随</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎小伙伴们~本站点在缓慢升级~</title>
      <link href="archives/60500ffa.html"/>
      <url>archives/60500ffa.html</url>
      
        <content type="html"><![CDATA[<p>几月不见，是时候升级一下博客了。</p><p><img src="https://cdn2.sublimerui.top/2020/08/15/9929be5cb33ae.jpg" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/08/15/9929be5cb33ae.jpg" srcset="data:image/png;base64,666"></p><a id="more"></a><p>近期发现主题作者大大更新速度太快了55555……..</p><p>没过几个月，突然发现，自己的博客版本过于老旧了=-=</p><p>即日起，本博客正式从Volantis 2.6.6【<strong>缓慢</strong>】<del>跃迁</del>至最新版本！</p><p><img src="https://cdn2.sublimerui.top/2020/10/11/7fe97646a50de.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/10/11/7fe97646a50de.png" srcset="data:image/png;base64,666" alt="古老的主题版本"></p><p>但是，版本间有许多不兼容的地方，需要我一点点修改….加之12月26日考研临近，所以会比较缓慢=-=</p><p><del>（咳咳，其实我不会告诉你，自己是刷题累了闲来摸鱼改博客的）</del></p><hr><blockquote><p>所以呢，博客有很多不完善的地方，请各位大佬们见谅啦=-=</p></blockquote><blockquote><p>本考研狗在此祝大家考研都能上岸呀<del>~</del></p></blockquote><blockquote><p>祝大家心想事成，奥利给！</p></blockquote><p><img src="https://cdn2.sublimerui.top/2020/05/30/ffed597168779.jpg" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/05/30/ffed597168779.jpg" srcset="data:image/png;base64,666" alt="紫罗兰永恒花园"></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用OpenCV实现对车流量的统计</title>
      <link href="archives/48ab4a6e.html"/>
      <url>archives/48ab4a6e.html</url>
      
        <content type="html"><![CDATA[<p>博主又有几个月没消息了。去哪里了呢？是的，考研闲暇之余，短时间摸鱼后，他，又灰溜溜地回来了。</p><p>博主最近在干啥？详见<a href="https://blog.cwxyr.me/archives/195/">一枚考研狗的执着</a></p><p><img src="https://cdn2.sublimerui.top/2020/07/14/7b9c439ccbd61.jpg" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/7b9c439ccbd61.jpg" srcset="data:image/png;base64,666"></p><a id="more"></a><p>闲话少絮。开始正题——OpenCV的车流量统计。</p><h2 id="调试平台"><a href="#调试平台" class="headerlink" title="调试平台"></a>调试平台</h2><ul><li>OpenCV 4.2</li><li>VS 2019</li></ul><h2 id="汽车识别原理——背景-前景分割算法"><a href="#汽车识别原理——背景-前景分割算法" class="headerlink" title="汽车识别原理——背景/前景分割算法"></a>汽车识别原理——背景/前景分割算法</h2><p>如今，检测和提取车辆时候，常用的方法有MOG2算法和KNN算法。MOG算法是以高斯混合模型（GMM）为基础的背景/前景分割算法。它是以2004年和2006年Z.Zivkovic的两篇文章为基础的。这个算法的一个特点是它为每一个像素选择一个合适数目的高斯分布。其主要原理为：在一个固定位置和角度固定的视频或图像中，提取分割图像或视频中运动的成分。此算法使用背景建模的方式，将整张图片或一帧视频分为前景和后景。此算法运行时，会将动态的前景与静止的后景相减，得出结果即为徐提取的运动物体的图像。</p><p>K最近邻算法（KNN）是属于机器学习的一种算法。其主要原理为：给定一个已训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近（注：衡量邻近的标准以具体选取的某个特征而言，例如下面示意图中使用的特征为欧式距离）的K个实例，这K个实例的多数属于某个类，则判定该输入实例同属此类。如下图所示：训练者取k值，计算以欧氏距离k为半径的圆内其他类别的个数，图中中心小红点以k为半径的圆内三角形个数最多，则判定中心小红点为三角形。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/cec057608abab.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/cec057608abab.png" srcset="data:image/png;base64,666" alt="KNN"></p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><h3 id="整体流程框架图"><a href="#整体流程框架图" class="headerlink" title="整体流程框架图"></a>整体流程框架图</h3><p>本程序的主要运行流程为：程序运行开始，首先从文件中获取上次保存的光流量检测矩形框数据（顶点坐标和矩形的长宽）；其后，分别初始化背景提取对象，使用MOG2和KNN两种算法。与此同时，建立一个鼠标回调函数，用于捕获鼠标左键（绘制矩形框）、中键（取消操作）和右键（保存矩形框数据到文件）的操作。</p><p>此后，程序进入主循环状态。程序循环从视频中获取一帧的图像，先进行压缩处理，以提高后续运算速度。之后，将这一帧图片从RGB转为灰度图片。为了祛除灰度后可能出现的小毛刺杂点，再进行平滑滤波处理。此后，分别通过MOG2和KNN算法提取前景，并将提取后的视频显示出来。与此同时，获取每个矩形框中积分后的亮度和。</p><p>最后，两个算法中，分别将实时得到的亮度和与所预设的阈值进行比较，当满足条件后，便认为一辆汽车通过矩形框，使得计数器加一。如此重复，统计整个视频中的车流量。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/adbf3842b3b5f.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/adbf3842b3b5f.png" srcset="data:image/png;base64,666" alt="流程图"></p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ol><li><code>int detectTHD</code></li></ol><blockquote><p>此参数为预设的亮度阈值。确定是否有汽车经过检测框中，其需要联合上一帧积分亮度和本次积分亮度后综合做出决定。</p></blockquote><ol start="2"><li><code>cv::Size newSize(frame.cols / 2, frame.rows / 2);</code></li></ol><blockquote><p>此参数可以储存一帧视频缩小后的大小。</p></blockquote><ol start="3"><li><code>cv::Mat showMat;</code></li></ol><blockquote><p>此参数用于储存最终显示的图像矩阵。</p></blockquote><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><ol><li><code>static void onMouse(int event, int x, int y, int flags, void\*)</code></li></ol><blockquote><p>此函数主要用于检测鼠标左键、滑轮（中键）和右键的一些操作，用于绘制矩形检测框。</p></blockquote><ol start="2"><li><code>cv::resize(frame, newframe, newSize);</code></li></ol><blockquote><p>此函数主要用于缩小原视频比例，提高计算机运算速度。</p></blockquote><ol start="3"><li><code>bgMOG2-\&gt;apply(greyFrame, mog2RES, update_bg_model ? -1 : 0);</code>以及<code>bgKNN-\&gt;apply(greyFrame, KNN, update_bg_model ? -1 : 0);</code></li></ol><blockquote><p>apply函数主要用于两种算法的前景提取。此后，前景提取后的这帧视频保存于bgMOG2和bgKNN之中。</p></blockquote><ol start="4"><li><code>cv::rectangle(showMat, myLanneRect.at(k), cv::Scalar(255, 255, 255), 3);</code></li></ol><blockquote><p>此函数主要用于前景提取后在其上面绘制矩形框。</p></blockquote><ol start="5"><li><code>cv::integral(subMat, sumMat, CV_32S);</code></li></ol><blockquote><p>计算车道矩形框亮度积分图。</p></blockquote><ol start="6"><li><code>cv::putText();</code></li></ol><blockquote><p>此函数可以按照要求，在视频图像上显示文字和统计数字。</p></blockquote><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol><li><strong>功能测试</strong></li></ol><p>进行车流量统计前，应当首先根据矩形框中出现车辆时，估算其亮度平均值作为亮度阈值，使其设定为一个较为合适的值，增强检测的灵敏性。由下图可知，当程序运行后，通过手动标记车道检测区域，得到2个矩形检测区。每次获得矩形中的积分亮度结果，当上从亮度结果大于阈值，且此次亮度结果小于阈值时，使车辆统计结果加一。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/6bb48c736d423.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/6bb48c736d423.png" srcset="data:image/png;base64,666" alt="功能测试"></p><ol start="2"><li><strong>算法处理时间</strong></li></ol><p>由测试结果可知，相较于MOG2算法，KNN算法在运算处理上花费更多的时间，KNN算法时间约为MOG2时间的2倍。同时，算法处理总时间也相对较长，除了两个算法所带来的开销外，仍有其他附加代码所花费的时间。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/eddddc18068b8.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/eddddc18068b8.png" srcset="data:image/png;base64,666" alt="时间处理"></p><ol start="3"><li><strong>缩放图片前后比较</strong></li></ol><p>程序中，可以使用<code>cv::resize();</code>函数进行图片的压缩，缩放图片对于检测速度有较大的影响。不使用缩放时，将视频中原始一帧的图像进行计算，经测试发现，处理速度很慢，显示的图片有明显的脱帧和卡顿现象，CPU占用率相当高，与压缩后（上图）相比，无论使用MOG2还是KNN算法，其处理时间均成倍增加。下图为不使用缩小图片尺寸条件下的处理时间。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/9ea91e56e17a6.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/9ea91e56e17a6.png" srcset="data:image/png;base64,666" alt="时间对比"></p><ol start="4"><li><strong>矩形检测区亮度阈值的影响</strong></li></ol><p>阈值设置的合理性也是车流量检测准确性的一个重要指标。过高或过低的阈值均不能很好地反映车辆的经过和实现的统计。阈值过低，将会把视频中环境干扰噪声和其他运动对象（如三轮车和行人）当做汽车统计，使得统计结果偏大；同理，阈值过高，将很难检测到车辆的通过，当车辆进过矩形检测区时，无法实现车辆的统计。本程序中，经过检测矩形框内平均值的大致估算，将阈值<code>detectTHD</code>设置为900000。</p><p>下图中显示了当阈值设定过小时的状况。右端矩形框（右车道）经过了一辆电动车，程序误认为汽车，并错误地将统计结果L1的值从1加为2。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/42ebf686fb258.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/42ebf686fb258.png" srcset="data:image/png;base64,666" alt="阈值过小"></p><p>同理，当阈值设置过大，也会造成统计的不准确。下图显示了当阈值设定过大时的状况。可以发现，即使是车辆经过了矩形框，车辆统计变量L0和L1仍为0。</p><p><img src="https://cdn2.sublimerui.top/2020/07/14/138c1e1078634.png" class="lazyload" data-srcset="https://cdn2.sublimerui.top/2020/07/14/138c1e1078634.png" srcset="data:image/png;base64,666" alt="阈值过大"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由以上分析可知，汽车流量的统计可以借助设定矩形区域内的亮度阈值来确定。为识别运动对象（汽车）的状态，可使用背景提取算法，如本软件中使用到的MOG2和KNN算法。通过比较不同算法间的处理时间，我们应当合理选择一种耗时短且提取车辆准确性高的一种算法。此外，识别统计车流量较为重要的一环便是设置合理的亮度阈值，亮度阈值设置的合理性直接关系到车流量统计准确性。</p><h2 id="附：程序源代码"><a href="#附：程序源代码" class="headerlink" title="附：程序源代码"></a>附：程序源代码</h2><p><strong>此项目Github地址：</strong> <a href="https://github.com/cwxyr/traffic-detection">https://github.com/cwxyr/traffic-detection</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/video.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420d.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===【鼠标事件回调函数】===</span></span><br><span class="line"><span class="keyword">int</span> detectTHD = <span class="number">900000</span>;<span class="comment">//亮度阈值：有车辆经过的；</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;myLanneLightSum_Last;<span class="comment">//车道亮度和：上一帧的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;myLanneVihicleCnt;<span class="comment">//车道车辆计数器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Rect&gt;myLanneRect;<span class="comment">//车道矩形框；显示为红色；</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt;myMousePoints;<span class="comment">//鼠标点向量；显示为蓝色；</span></span><br><span class="line"><span class="keyword">int</span>myMouseEventBusy = <span class="number">0</span>;<span class="comment">//鼠标回调事件忙:简单的资源锁</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onMouse</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myMouseEventBusy = <span class="number">1</span>;</span><br><span class="line">cv::Point  mPoint;</span><br><span class="line">cv::Rect mRect;</span><br><span class="line"><span class="keyword">switch</span> (event)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> cv::EVENT_LBUTTONDOWN:<span class="comment">//左键按下:增加myMousePoints中的点数</span></span><br><span class="line">mPoint = cv::Point(x, y);</span><br><span class="line">myMousePoints.push_back(mPoint);<span class="comment">//将当前鼠标点推送到向量中；</span></span><br><span class="line"><span class="keyword">if</span> (myMousePoints.size() &gt; <span class="number">4</span>)</span><br><span class="line">myMousePoints.erase(myMousePoints.begin());<span class="comment">//保证myMousePoints向量中节点数不大于4；</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> cv::EVENT_RBUTTONDOWN:<span class="comment">//右键键按下：将myMousePoints中的4个点推送到矩形框向量myLanneRect</span></span><br><span class="line"><span class="keyword">if</span> (myMousePoints.size() == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Xmin = <span class="number">100000</span>; <span class="keyword">int</span> Ymin = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> Xmax = <span class="number">0</span>; <span class="keyword">int</span> Ymax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">Xmin = <span class="built_in">std</span>::min(Xmin, myMousePoints.at(k).x);</span><br><span class="line">Ymin = <span class="built_in">std</span>::min(Ymin, myMousePoints.at(k).y);</span><br><span class="line">Xmax = <span class="built_in">std</span>::max(Xmax, myMousePoints.at(k).x);</span><br><span class="line">Ymax = <span class="built_in">std</span>::max(Ymax, myMousePoints.at(k).y);</span><br><span class="line">&#125;<span class="comment">//for k   &lt;&lt;&lt; === 用四个点构成矩形框的参数</span></span><br><span class="line">mRect = cv::Rect(Xmin, Ymin, Xmax - Xmin, Ymax - Ymin);<span class="comment">//构成矩形框</span></span><br><span class="line">myLanneRect.push_back(mRect);</span><br><span class="line">myLanneLightSum_Last.push_back(<span class="number">0</span>);</span><br><span class="line">myLanneVihicleCnt.push_back(<span class="number">0</span>);</span><br><span class="line">myMousePoints.clear();  <span class="comment">//清除鼠标点向量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">///if</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> cv::EVENT_MBUTTONDOWN:<span class="comment">//中间键键按下：删除myMousePoints中的一个点；myMousePoints为空时，删除myLanneRect中的节点；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EVENT_MBUTTONDOWN\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (myMousePoints.size() &gt; <span class="number">0</span>)</span><br><span class="line">myMousePoints.pop_back();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">myLanneRect.pop_back();</span><br><span class="line">myLanneLightSum_Last.pop_back();</span><br><span class="line">myLanneVihicleCnt.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/////switch</span></span><br><span class="line">myMouseEventBusy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> errorMSG[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> curPathName[<span class="number">384</span>] = <span class="string">&quot;&quot;</span>; <span class="keyword">char</span> curModulerPath[<span class="number">384</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">GetCurrentDirectory(<span class="number">383</span>, curModulerPath); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Line39: curModulerPath = %s\n&quot;</span>, curModulerPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======读取标记的矩形框文件内容到myLanneRect：=======</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READ_RECT_FILE</span></span><br><span class="line">FILE *pFILE = fopen(<span class="string">&quot;MarkRect.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFILE != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cv::Rect  mRect;</span><br><span class="line"><span class="keyword">while</span> (fgets(errorMSG, <span class="number">255</span>, pFILE) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rtn = <span class="built_in">sscanf</span>(errorMSG, <span class="string">&quot;%d %d %d %d&quot;</span>, &amp;mRect.x, &amp;mRect.y, &amp;mRect.width, &amp;mRect.height);</span><br><span class="line"><span class="keyword">if</span> (rtn == <span class="number">4</span>) &#123;</span><br><span class="line">myLanneRect.push_back(mRect);</span><br><span class="line">myLanneLightSum_Last.push_back(<span class="number">0</span>);</span><br><span class="line">myLanneVihicleCnt.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(pFILE);</span><br><span class="line">&#125;<span class="comment">///if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !READ_RECT_FILE</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>  imgName = <span class="string">&quot;video-02.mp4&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> FilePath[<span class="number">384</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(curPathName) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">sprintf</span>(FilePath, <span class="string">&quot;%s\\%s&quot;</span>, curPathName, imgName.c_str());<span class="comment">//图片文件路径</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">sprintf</span>(FilePath, <span class="string">&quot;%s&quot;</span>, imgName.c_str());<span class="comment">//图片文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//==【01】== 打开视频文件或摄像头</span></span><br><span class="line">cv::VideoCapture cap; <span class="comment">//VideoCapture类实例化，使用缺省摄像头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &amp;&amp; <span class="string">&quot;UsingCam&quot;</span>)</span><br><span class="line">cap.open(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cap.open(FilePath);</span><br><span class="line"><span class="keyword">if</span> (!cap.isOpened()) <span class="comment">// check if we succeeded</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error#73: 打开设备或文件失败，检查是否存在！回车退出！\n路径=%s\n&quot;</span>, FilePath);</span><br><span class="line">fgets(FilePath, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv::Mat frame, newframe, greyFrame, floatFrame, lastFrame, frame2, mog2RES, KNN, out_frame, avgFrame;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; diffIMGvec;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==【02】== 创建运动视频背景提取对象：用于分离背景和运动对象</span></span><br><span class="line">cv::Ptr&lt;cv::BackgroundSubtractorMOG2&gt; bgMOG2 = cv::createBackgroundSubtractorMOG2();</span><br><span class="line">cv::Ptr&lt;cv::BackgroundSubtractorKNN&gt; bgKNN = cv::createBackgroundSubtractorKNN();</span><br><span class="line">bgMOG2-&gt;setVarThreshold(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">bool</span> update_bg_model = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//==【03】== 命名几个显示窗口</span></span><br><span class="line">cv::namedWindow(<span class="string">&quot;RawWnd&quot;</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::setMouseCallback(<span class="string">&quot;RawWnd&quot;</span>, onMouse, &amp;newframe);<span class="comment">//设置鼠标事件回调函数（&quot;RawWnd&quot;窗口的）：同时传递彩色图像指针；</span></span><br><span class="line">cv::namedWindow(<span class="string">&quot;Out_KNN&quot;</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::namedWindow(<span class="string">&quot;Out_MOG2&quot;</span>, cv::WINDOW_NORMAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frameNums = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">frame.rows = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> t1 = (<span class="keyword">double</span>)cv::getCPUTickCount();  <span class="comment">//开始统计时间</span></span><br><span class="line">cap.read(frame);</span><br><span class="line"><span class="keyword">if</span> (frame.rows == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="function">cv::Size <span class="title">newSize</span><span class="params">(frame.cols / <span class="number">2</span>, frame.rows / <span class="number">2</span>)</span></span>;  <span class="comment">//压缩图像，将其尺寸缩小</span></span><br><span class="line">cv::resize(frame, newframe, newSize);</span><br><span class="line">cv::cvtColor(newframe, greyFrame, cv::COLOR_RGB2GRAY);  <span class="comment">//转换为灰度图</span></span><br><span class="line">cv::blur(greyFrame, greyFrame, cv::Size(<span class="number">3</span>, <span class="number">3</span>));<span class="comment">//使用平滑运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> t2 = (<span class="keyword">double</span>)cv::getCPUTickCount();</span><br><span class="line">bgMOG2-&gt;apply(greyFrame, mog2RES, update_bg_model ? <span class="number">-1</span> : <span class="number">0</span>);   <span class="comment">//使用MOG2算法提取前景</span></span><br><span class="line"><span class="keyword">double</span> t3 = (<span class="keyword">double</span>)cv::getCPUTickCount();  <span class="comment">//获取处理时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> t4 = (<span class="keyword">double</span>)cv::getCPUTickCount();</span><br><span class="line">bgKNN-&gt;apply(greyFrame, KNN, update_bg_model ? <span class="number">-1</span> : <span class="number">0</span>);<span class="comment">//使用KNN算法提取前景</span></span><br><span class="line"><span class="keyword">double</span> t5 = (<span class="keyword">double</span>)cv::getCPUTickCount();  <span class="comment">//获取处理时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MOG2 Time = %.3fms\n&quot;</span>, <span class="number">1e0</span> * (t3 - t2) / (<span class="keyword">double</span>)cv::getTickFrequency());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KNN Time = %.3fms\n&quot;</span>, <span class="number">1e0</span> * (t5 - t4) / (<span class="keyword">double</span>)cv::getTickFrequency());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Time = %.3fms\n&quot;</span>, <span class="number">1e0</span> * (t5 - t1) / (<span class="keyword">double</span>)cv::getTickFrequency());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mog2RES.empty())  <span class="comment">//计算MOG2算法下矩形框的积分亮度值</span></span><br><span class="line">&#123;</span><br><span class="line">cv::Mat showMat;</span><br><span class="line">mog2RES.copyTo(showMat);</span><br><span class="line"><span class="keyword">if</span> (myMouseEventBusy == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; myLanneRect.size(); k++)</span><br><span class="line">&#123;</span><br><span class="line">cv::rectangle(showMat, myLanneRect.at(k), cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">cv::Mat subMat = mog2RES(myLanneRect.at(k));<span class="comment">//再MOG2的前景提取结果中，取车道标记矩形框区域为subMat矩阵</span></span><br><span class="line">cv::Mat sumMat;<span class="comment">//积分图 == subMat的积分矩阵</span></span><br><span class="line">cv::integral(subMat, sumMat, CV_32S);<span class="comment">//设置积分矩阵的数据类型为uint；</span></span><br><span class="line"><span class="keyword">int</span> sumValue = (<span class="keyword">int</span>)sumMat.at&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>)sumMat.rows - <span class="number">1</span>, (<span class="keyword">int</span>)sumMat.cols - <span class="number">1</span>);  <span class="comment">//获取积分图右下角的值，就是矩形框内亮度和；</span></span><br><span class="line"><span class="built_in">sprintf</span>(errorMSG, <span class="string">&quot;sum = %d;&quot;</span>, sumValue);</span><br><span class="line">cv::putText(showMat, errorMSG, cv::Point(myLanneRect.at(k).x, myLanneRect.at(k).y + <span class="number">4</span>), <span class="number">0.2</span>, <span class="number">1</span>, cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>);<span class="comment">//显示矩形框内的亮度和；</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//for k</span></span><br><span class="line">&#125;<span class="comment">////if</span></span><br><span class="line">cv::imshow(<span class="string">&quot;Out_MOG2&quot;</span>, showMat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!KNN.empty())   <span class="comment">//计算KNN算法下矩形框的积分亮度值</span></span><br><span class="line">&#123;</span><br><span class="line">cv::Mat showMat;</span><br><span class="line">KNN.copyTo(showMat);</span><br><span class="line"><span class="keyword">if</span> (myMouseEventBusy == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; myLanneRect.size(); k++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cv::rectangle(showMat, myLanneRect.at(k), cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">cv::Mat subMat = KNN(myLanneRect.at(k));<span class="comment">//再KNN的前景提取结果中，取车道标记矩形框区域为subMat矩阵</span></span><br><span class="line">cv::Mat sumMat;<span class="comment">//积分图 == subMat的积分矩阵</span></span><br><span class="line">cv::integral(subMat, sumMat, CV_32S);<span class="comment">//设置积分矩阵的数据类型为uint；</span></span><br><span class="line"><span class="keyword">int</span> sumValue = (<span class="keyword">int</span>)sumMat.at&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>)sumMat.rows - <span class="number">1</span>, (<span class="keyword">int</span>)sumMat.cols - <span class="number">1</span>);  <span class="comment">//获取积分图右下角的值，就是矩形框内亮度和；</span></span><br><span class="line"><span class="built_in">sprintf</span>(errorMSG, <span class="string">&quot;sum = %d;&quot;</span>, sumValue);</span><br><span class="line">cv::putText(showMat, errorMSG, cv::Point(myLanneRect.at(k).x, myLanneRect.at(k).y + <span class="number">4</span>), <span class="number">0.2</span>, <span class="number">1</span>, cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>);<span class="comment">//显示矩形框内的亮度和；</span></span><br><span class="line">&#125;<span class="comment">//for k</span></span><br><span class="line">&#125;<span class="comment">////if</span></span><br><span class="line">imshow(<span class="string">&quot;Out_KNN&quot;</span>, showMat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===&gt;&gt;&gt; 显示原始图像：显示车道标记信息 + 矩形框内亮度和 + 车流量统计</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHOW_RAW_MAT</span></span><br><span class="line">cv::Mat showMat;</span><br><span class="line">newframe.copyTo(showMat); <span class="comment">//矩阵复制</span></span><br><span class="line"><span class="built_in">sprintf</span>(errorMSG, <span class="string">&quot;mL=add Point; mR=add Rect; mM=delete Point;&quot;</span>);</span><br><span class="line">cv::putText(showMat, errorMSG, cv::Point(<span class="number">8</span>, <span class="number">32</span>), <span class="number">0.2</span>, <span class="number">1</span>, cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>);<span class="comment">//显示提示信息；</span></span><br><span class="line"><span class="comment">//==&gt;&gt; 显示车道矩形框为红色 + 车流量统计 + 车流量显示</span></span><br><span class="line"><span class="keyword">if</span> (myMouseEventBusy == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; myLanneRect.size(); k++)</span><br><span class="line">&#123;</span><br><span class="line">cv::rectangle(showMat, myLanneRect.at(k), cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">cv::Mat subMat = mog2RES(myLanneRect.at(k));<span class="comment">//再MOG2的前景提取结果中，取车道标记矩形框区域为subMat矩阵</span></span><br><span class="line">cv::Mat sumMat;<span class="comment">//积分图 == subMat的积分矩阵</span></span><br><span class="line">cv::integral(subMat, sumMat, CV_32S);<span class="comment">//设置积分矩阵的数据类型为int，计算车道矩形框内亮度积分图；</span></span><br><span class="line"><span class="keyword">int</span> sumValue = (<span class="keyword">int</span>)sumMat.at&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>)sumMat.rows - <span class="number">1</span>, (<span class="keyword">int</span>)sumMat.cols - <span class="number">1</span>);  <span class="comment">//获取积分图右下角的值，就是矩形框内亮度和；</span></span><br><span class="line"><span class="built_in">sprintf</span>(errorMSG, <span class="string">&quot;sum = %d;&quot;</span>, sumValue);</span><br><span class="line">cv::putText(showMat, errorMSG, cv::Point(myLanneRect.at(k).x, myLanneRect.at(k).y + <span class="number">4</span>), <span class="number">0.2</span>, <span class="number">1</span>, cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);<span class="comment">//显示矩形框内的亮度和；</span></span><br><span class="line"><span class="comment">//===&gt;&gt;&gt; 车流量统计：</span></span><br><span class="line"><span class="keyword">if</span> (myLanneLightSum_Last.at(k) &gt; detectTHD &amp;&amp; sumValue &lt;= detectTHD)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//:: 车辆通过了矩形框：上一帧亮度和大于阈值，本帧亮度和小于阈值；车辆计数器自加；</span></span><br><span class="line">myLanneVihicleCnt.at(k)++;</span><br><span class="line">myLanneLightSum_Last.at(k) = sumValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">myLanneLightSum_Last.at(k) = sumValue;  <span class="comment">//存储当前亮度和到myLanneLightSum_Last</span></span><br><span class="line">&#125;<span class="comment">//for k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===&gt;&gt; 车流量统计结果显示</span></span><br><span class="line">cv::Mat topareaMat = showMat(cv::Rect(<span class="number">0</span>, <span class="number">0</span>, showMat.cols, <span class="number">75</span>));<span class="comment">//最顶部48行置0；</span></span><br><span class="line">topareaMat *= <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strVihicleCnt = <span class="string">&quot;VihicleCnt: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; myLanneRect.size(); k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(errorMSG, <span class="string">&quot;L%d = %d;&quot;</span>, k, myLanneVihicleCnt.at(k));</span><br><span class="line">strVihicleCnt += errorMSG;</span><br><span class="line">&#125;</span><br><span class="line">cv::putText(showMat, strVihicleCnt.c_str(), cv::Point(<span class="number">8</span>, <span class="number">64</span>), <span class="number">0.2</span>, <span class="number">1</span>, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>); <span class="comment">//流量统计显示到彩色图片上</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">////if</span></span><br><span class="line"> <span class="comment">//==&gt;&gt; 显示正在标记的坐标点为蓝色：</span></span><br><span class="line"><span class="keyword">if</span> (myMouseEventBusy == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; myMousePoints.size(); k++)</span><br><span class="line">&#123;</span><br><span class="line">cv::line(showMat, myMousePoints.at(k - <span class="number">1</span>), myMousePoints.at(k), cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">15</span>);</span><br><span class="line">&#125;<span class="comment">//for k</span></span><br><span class="line"><span class="keyword">if</span>(myMousePoints.size() == <span class="number">4</span>)</span><br><span class="line">cv::line(showMat, myMousePoints.at(<span class="number">0</span>), myMousePoints.at(<span class="number">3</span>), cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">&#125;<span class="comment">////if</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">&quot;RawWnd&quot;</span>, showMat);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHOW_RAW_MAT</span></span></span><br><span class="line"><span class="keyword">int</span> keycode = cv::waitKey(<span class="number">100</span>);<span class="comment">//等待100ms</span></span><br><span class="line"><span class="keyword">if</span> (keycode == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">update_bg_model = !update_bg_model;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Learn background is in state = %d\n&quot;</span>, update_bg_model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//写文件：记录标记的矩形框到文件中：</span></span><br><span class="line">#ifndef WRITE_RECT_FILE</span><br><span class="line">FILE *pFILE = fopen(<span class="string">&quot;MarkRect.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFILE != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; myLanneRect.size(); k++) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(pFILE, <span class="string">&quot;%d %d %d %d\n&quot;</span>, myLanneRect.at(k).x, myLanneRect.at(k).y, myLanneRect.at(k).width, myLanneRect.at(k).height);</span><br><span class="line">&#125;</span><br><span class="line">fclose(pFILE);</span><br><span class="line">&#125;<span class="comment">///if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !WRITE_RECT_FILE</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">frameNums++;</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">&#125;<span class="comment">//for </span></span><br><span class="line">cap.release();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV, 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开往-Travelling</title>
      <link href="archives/aca9eb9b.html"/>
      <url>archives/aca9eb9b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/cwxyr/mycdn@master/travellings_1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/cwxyr/mycdn@master/travellings_1.png" srcset="data:image/png;base64,666" alt="开往-友链接力" width=500></img></p><p>互联网将人与人之间的距离大大减小，却还是形成了大大小小的孤岛。只有熟人间才知道彼此，而陌生人永远只能是陌生人。</p><a id="more"></a><h2 id="Travelling"><a href="#Travelling" class="headerlink" title="Travelling"></a>Travelling</h2><blockquote><p><strong>茫茫星辰中，去寻找不一样的、别致的星球。</strong></p></blockquote><p>这就是<code>开往-Travelling</code>。将一个个独立的个人星球连接起来，去探索下一个未知的人。</p><p>一块徽标，占用一个小地方，就这样简单地和他人联系在了一起。</p><h2 id="开往下一个世界"><a href="#开往下一个世界" class="headerlink" title="开往下一个世界"></a><code>开往</code>下一个世界</h2><blockquote><p>这是一个不一样的<a href="https://github.com/volfclub/travellings">Github项目</a>，在issue中提交申请，几日内就会受理。</p></blockquote><p>但是申请的网站必须满足几点要求：</p><p>愿为开放的网络做出贡献（如分享知识经验设计等）；<br>没有违法以及影响体验的内容（如侵入式广告等）；<br>正常更新维护中（国内无法正常访问会被移除）；<br>强制启用 https 。</p><blockquote><p><strong>下面就是通向异域的按钮。</strong><br><a href="https://travellings.now.sh/" target="blank" title="开往-友链接力"><img src="https://travellings.now.sh/assets/logo.gif#vwid=160&vhei=40" class="lazyload" data-srcset="https://travellings.now.sh/assets/logo.gif#vwid=160&vhei=40" srcset="data:image/png;base64,666" alt="开往-友链接力" width="120"></a></p></blockquote><h2 id="闲话絮语"><a href="#闲话絮语" class="headerlink" title="闲话絮语"></a>闲话絮语</h2><p>偶然的机会，发现Github上面有这样的一个项目，点击<code>Travelling</code>之后，目标博客随机跳转，开启了一个又一个新世界。正如你所看到的，网站页脚已经加上<code>Travelling</code>的徽标啦~ </p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 友链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用OpenCV对图像和视频进行载入和访问</title>
      <link href="archives/3ad132bb.html"/>
      <url>archives/3ad132bb.html</url>
      
        <content type="html"><![CDATA[<p>很久都没更新博客了（跪）….<strong>前期因为疫情和考研压力，所以就一直<del>咕咕咕</del></strong></p><p>在家上网课，学习OpenCV，做了一点笔记吧。<br>抽空写博客，仍然更新很慢（<del>大声哭泣</del>）</p><a id="more"></a><h2 id="运行平台"><a href="#运行平台" class="headerlink" title="运行平台"></a>运行平台</h2><ul><li>OpenCV 4.2</li><li>VS 2019</li></ul><h2 id="图像在内存中的存储和操作"><a href="#图像在内存中的存储和操作" class="headerlink" title="图像在内存中的存储和操作"></a>图像在内存中的存储和操作</h2><h3 id="从图像数据性质推理图像在内存中的存储方式："><a href="#从图像数据性质推理图像在内存中的存储方式：" class="headerlink" title="从图像数据性质推理图像在内存中的存储方式："></a>从图像数据性质推理图像在内存中的存储方式：</h3><blockquote><p>图像数据是多通道：1/3/4通道；<br>像素数据类型：1位，uchar，short，int，float，double等；</p></blockquote><h3 id="OpenCV中的C-Mat类："><a href="#OpenCV中的C-Mat类：" class="headerlink" title="OpenCV中的C++ Mat类："></a>OpenCV中的C++ Mat类：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">Mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// …大量方法…</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*! includes several bit-fields:</span></span><br><span class="line"><span class="comment">         - the magic signature</span></span><br><span class="line"><span class="comment">         - continuity flag</span></span><br><span class="line"><span class="comment">         - depth</span></span><br><span class="line"><span class="comment">         - number of channels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the array dimensionality, &gt;= 2</span></span><br><span class="line">    <span class="keyword">int</span> dims;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions</span></span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! pointer to the data</span></span><br><span class="line">    uchar* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>图像在内存中的基本要素：</p></blockquote><p>①列数cols = 宽度，行数rows = 高度，通道数（彩色空间类型），位深度（数据类型：8位无符号8U，32位浮点32F等）；<br>②像素存储区（uchar* data;）</p><blockquote><p>创建Mat矩阵–通过构造函数：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(Size(<span class="number">320</span>,<span class="number">240</span>), CV_8UC3)</span></span>;`</span><br></pre></td></tr></table></figure><p>宽度(320)，高度(240)，数据类型8U(8位无符号)，3通道</p><blockquote><p>创建Mat矩阵–通过create函数：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat img;</span><br><span class="line"></span><br><span class="line">img .create(Size(<span class="number">320</span>,<span class="number">240</span>), CV_32FC3);<span class="comment">//32位浮点型</span></span><br></pre></td></tr></table></figure><blockquote><p>创建载入图像文件：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;lena.jpg&quot;</span>, CV_LOAD_IMAGE_COLOR);</span><br></pre></td></tr></table></figure><h3 id="像素数据在内存中的组织方式："><a href="#像素数据在内存中的组织方式：" class="headerlink" title="像素数据在内存中的组织方式："></a>像素数据在内存中的组织方式：</h3><p><strong>PS:内存是顺序排列的字节阵列</strong></p><p><fancybox><img src="https://img.vim-cn.com/3e/ac56d209f474e08b9df75a04231a4547d3e240.jpg" class="lazyload" data-srcset="https://img.vim-cn.com/3e/ac56d209f474e08b9df75a04231a4547d3e240.jpg" srcset="data:image/png;base64,666" alt="img"></fancybox></p><h2 id="通过Mat方法访问图像像素"><a href="#通过Mat方法访问图像像素" class="headerlink" title="通过Mat方法访问图像像素"></a>通过Mat方法访问图像像素</h2><ol><li>3通道24位深度（表达每个通道占用8位）彩色图像像素的访问：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv::Vec3b pixlsValue; <span class="comment">//==表达这是一个3字节像素数据节点;</span></span><br><span class="line"></span><br><span class="line">pixlsValue = img.at&amp;lt;cv::Vec3b&amp;gt;(y, x);</span><br><span class="line"><span class="comment">//y表达行号；x表达列号；尖括号&lt;...&gt;中的内容是C++模板，指定图像矩阵的数据类型；</span></span><br></pre></td></tr></table></figure><ol start="2"><li>像素值的修改方法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pixlsValue.val[<span class="number">0</span>] = xxx;</span><br><span class="line">pixlsValue.val[<span class="number">1</span>] = xxx;</span><br><span class="line">pixlsValue.val[<span class="number">2</span>] = xxx;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改后的像素值返回到存储器：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.at&lt;cv::Vec3b&gt;(y, x) = pixlsValue；其中，y和x为像素坐标;</span><br></pre></td></tr></table></figure><h2 id="通过C-指针方法访问图像像素"><a href="#通过C-指针方法访问图像像素" class="headerlink" title="通过C++指针方法访问图像像素"></a>通过C++指针方法访问图像像素</h2><ol><li><p>图像行列数<code>Rows</code>和<code>Cols</code>，数据首地址 <code>uchar* data</code>，通道数<code>chaN</code>，每行总字节数byteR可通过矩阵类接口获得；</p></li><li><p>每个像素的字节数<code>byteN= 位深度/8</code>；位深度24位彩色图像每个像素占用3字节；float类型单通道图像每个像素占用4字节；…</p></li><li><p>每行总字节数<code>byteR = 每像素字节数 * 列数 = byteN * Cols</code>;</p></li><li><p>第<code>row</code>行第<code>col</code>列像素向量的地址偏移量（相对像素数据首字节）：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixlAddr = row * byteR + col * byteN ；</span><br></pre></td></tr></table></figure><ol start="5"><li><p>像素向量首字节地址为 <code>(uchar *)&amp;data [pixlAddr]</code>;</p></li><li><p>如果是<code>uchar</code>型图像，则像素首地址为：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uchar  *pixlPTR = (uchar*) data [pixlAddr];</span><br></pre></td></tr></table></figure><ol start="7"><li>如果是<code>float</code>型图像，则像素首地址为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> *pixlPTR = (<span class="keyword">float</span>*) data [pixlAddr];</span><br></pre></td></tr></table></figure><ol start="8"><li><p>对于3通道8位（位深度24位）彩色图像(RGB)，则3个彩色通道像素存储位置为：<code>pixlPTR[0] = B</code> 、<code>pixlPTR[1] = G </code>、<code>pixlPTR[2] = R</code>；</p></li><li><p>通过实验可以证明，使用C++指针访问像素，时间开销远低于调用<code>cv::Mat.at()</code>方法；</p></li></ol><h2 id="图像像素访问例程"><a href="#图像像素访问例程" class="headerlink" title="图像像素访问例程"></a>图像像素访问例程</h2><figure class="highlight cpp"><figcaption><span>完整代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;Windows.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/core.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/imgproc.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/highgui.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/features2d.hpp&amp;gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> curPathName[<span class="number">384</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> FilePath[<span class="number">384</span>] = <span class="string">&quot;lena.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(curPathName) &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="built_in">sprintf</span>(FilePath, <span class="string">&quot;%s\\lena.jpg&quot;</span>, curPathName); <span class="comment">//图片文件路径</span></span><br><span class="line"></span><br><span class="line">    cv::Mat readImg = cv::imread(FilePath, cv::IMREAD_COLOR); <span class="comment">//读取彩色图片: opencv420的IMREAD_COLOR与之前版本不同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readImg.empty())</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;error#41: 未能读取到图片，检查文件是否存在！回车退出！\n图片路径=%s\n&quot;</span>, FilePath);</span><br><span class="line">         fgets(FilePath, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;readImg&quot;</span>, readImg);<span class="comment">//显示图片，窗口标题为readImg</span></span><br><span class="line">    cv::Mat imgFloat;</span><br><span class="line">    readImg.convertTo(imgFloat, CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在C++中，访问矩阵中的像素有两种方法：通过矩阵方法和通过指针；通过指针是最快的访问方法</span></span><br><span class="line">    cv::Vec3b colorValue; uchar greyValue;</span><br><span class="line">    <span class="keyword">int</span> channelNUMS = readImg.channels();</span><br><span class="line"></span><br><span class="line">    uchar *pDATA = readImg.data;         <span class="comment">//为了通过指针访问存储区，我们获取存储区的首指针</span></span><br><span class="line">    <span class="keyword">int</span> dataSTEP = readImg.step1();  <span class="comment">//注意，当图像列数cols=512，3通道时，dataSTEP值为512 * 3 = 1536；</span></span><br><span class="line">    <span class="keyword">int</span> dataSTEP2 = imgFloat.step1();    <span class="comment">//注意，当图像列数cols=512，3通道时，dataSTEP值为512 * 3 = 1536；</span></span><br><span class="line"></span><br><span class="line">    int64 timeSTART = cv::getTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; imgFloat.rows / <span class="number">2</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; readImg.cols; j++) &#123;</span><br><span class="line">             <span class="comment">//我们使用条件编译开关来控制使用那一段代码</span></span><br><span class="line">             <span class="meta">#<span class="meta-keyword">ifndef</span> ACCESS_IAMGE_BY_PTR      <span class="comment">//使用Mat的At()方法访问像素：花费时间几乎是指针方法的10倍；</span></span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">switch</span> (channelNUMS)</span><br><span class="line">             &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  readImg.at&amp;lt;uchar&amp;gt;(i, j) = <span class="number">255</span> - readImg.at&amp;lt;uchar&amp;gt;(i, j);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                  colorValue = readImg.at&amp;lt;cv::Vec3b&amp;gt;(i, j);</span><br><span class="line">                  colorValue.val[<span class="number">0</span>] = <span class="number">255</span> - colorValue.val[<span class="number">0</span>];</span><br><span class="line">                  colorValue.val[<span class="number">1</span>] = <span class="number">255</span> - colorValue.val[<span class="number">1</span>];</span><br><span class="line">                  colorValue.val[<span class="number">2</span>] = <span class="number">255</span> - colorValue.val[<span class="number">2</span>];</span><br><span class="line">                  readImg.at&amp;lt;cv::Vec3b&amp;gt;(i, j) = colorValue;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="meta">#<span class="meta-keyword">else</span>              <span class="comment">//使用指针方法访问像素：花费时间几乎是Mat的At()方法的1/10倍；</span></span></span><br><span class="line">             <span class="keyword">if</span> (pDATA[i * dataSTEP * <span class="keyword">sizeof</span>(uchar) + j * channelNUMS + <span class="number">0</span>] &gt; <span class="number">200</span> &amp;&amp;</span><br><span class="line">                  pDATA[i * dataSTEP * <span class="keyword">sizeof</span>(uchar) + j * channelNUMS + <span class="number">1</span>] &gt; <span class="number">200</span> &amp;&amp;</span><br><span class="line">                  pDATA[i * dataSTEP * <span class="keyword">sizeof</span>(uchar) + j * channelNUMS + <span class="number">2</span>] &gt; <span class="number">200</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                  pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 0] = 64;</span><br><span class="line">                  pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 1] = 64;</span><br><span class="line">                  pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 2] = 0;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                  pDATA[i * dataSTEP * <span class="keyword">sizeof</span>(uchar) + j * channelNUMS + <span class="number">0</span>] = <span class="number">255</span> - pDATA[i * dataSTEP * <span class="keyword">sizeof</span>(uchar) + j * channelNUMS + <span class="number">0</span>];</span><br><span class="line">                  pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 1] = 255 - pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 1];</span><br><span class="line">                  pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 2] = 255 - pDATA[i * dataSTEP * sizeof(uchar) + j * channelNUMS + 2];</span><br><span class="line">             &#125;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span> ACCESS_IAMGE_BY_PTR</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int64 timeEND = cv::getTickCount(); <span class="comment">//处理结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> usingTime = (<span class="keyword">double</span>)(timeEND - timeSTART) / (<span class="keyword">double</span>)cv::getTickFrequency();<span class="comment">//统计矩阵操作花费的时间，单位ms；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INFO#128: 图像处理耗时：%.6f 秒\n&quot;</span>, usingTime);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;Nagtive Film&quot;</span>, readImg);</span><br><span class="line">    cv::imwrite(<span class="string">&quot;Nagtive_Film.bmp&quot;</span>, readImg);       <span class="comment">//保存处理后的图像为bmp文件</span></span><br><span class="line">    cv::waitKey();<span class="comment">//等待按下键盘，这是程序退出前让显示窗得以被显示的方法！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>VS 2019实际运行效果如下：</p></blockquote><p><fancybox><img src="https://i.loli.net/2020/03/01/gcSkP8OZIwGhQRU.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/01/gcSkP8OZIwGhQRU.png" srcset="data:image/png;base64,666" alt="WOQ9@B(2}AH0A7L@J0GB9S1.png"></fancybox></p><h2 id="视频图像的特点"><a href="#视频图像的特点" class="headerlink" title="视频图像的特点"></a>视频图像的特点</h2><ol><li>视频源：摄像头和视频文件；</li><li>视频图像格式：AVI、VCD、SVCD、DVD、MPG、WMV、RM、RMVB、MOV、MP4、MPEG4、3GP、H264等等。</li><li>视频图像在硬盘中存储要求更高压缩比，压缩、解压缩处理的计算开销较大；</li><li>无论什么格式视频图像，载入到内存后将被转换为像素矩阵，并存储到内存中。此时，像素访问方法将与静止图像没有差异。</li></ol><h3 id="通过C-调用OpenCV库载入图像"><a href="#通过C-调用OpenCV库载入图像" class="headerlink" title="通过C++调用OpenCV库载入图像"></a>通过C++调用OpenCV库载入图像</h3><blockquote><p>这里使用C++和OpenCV库将视频载入内存，并将视频图像记录到另一个视频文件中</p></blockquote><p>可以发现：  </p><ul><li>视频是一个图像序列；</li><li>图像序列中的每幅图像仍以像素矩阵存储在内存中，访问方法与静止图像相同。</li><li>使用OpenCV记录的视频文件，仅仅存储了经过编码后的视频流数据，还不符合视频文件格式标准，不能使用常规的播放器来播放，需要使用一些特殊的视频播放器（例如VLC）来播放。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &quot;stdafx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;iostream&amp;gt;   <span class="comment">// for standard I/O</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;Windows.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/core.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/imgproc.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/highgui.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/features2d.hpp&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;opencv2/video.hpp&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;opencv_world420.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> curPathName[<span class="number">384</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==【01】== 打开视频文件或摄像头</span></span><br><span class="line">    <span class="keyword">char</span> FilePath[<span class="number">384</span>] = <span class="string">&quot;HighWay_Video_001.Avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(curPathName) &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="built_in">sprintf</span>(FilePath, <span class="string">&quot;%s\\HighWay_Video_001.Avi&quot;</span>, curPathName);   <span class="comment">//图片文件路径</span></span><br><span class="line">                                                             <span class="comment">//==【01】== 视频输入选择和打开：摄像头或视频文件</span></span><br><span class="line">         cv::String  path = FilePath;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">             path = argv[<span class="number">1</span>];        <span class="comment">//可通过命令行第二个参数指定视频文件名</span></span><br><span class="line">         <span class="comment">//path = &quot;&quot;;              //====&gt;&gt;&gt;&gt;如果启用此行，将从摄像头中读取视频图像&lt;&lt;&lt;&lt;====</span></span><br><span class="line">         cv::VideoCapture cap; <span class="comment">//VideoCapture类实例化，使用缺省摄像头</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(path.length() == <span class="number">0</span>)</span><br><span class="line">             cap.open(<span class="number">0</span>);       <span class="comment">//打开第一个摄像头</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             cap.open(path);  <span class="comment">//打开视频文件</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(!cap.isOpened()) <span class="comment">// check if we succeeded</span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    cv::Mat frame, greyFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==【02】== 视频记录类实例化</span></span><br><span class="line">         cv::VideoWriter outputVideo;                                        <span class="comment">// Open the output</span></span><br><span class="line">         <span class="keyword">int</span> saveAVIenable = <span class="number">0</span>;            <span class="comment">//非0时记录视频</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(saveAVIenable)&#123;</span><br><span class="line">             <span class="keyword">bool</span> rtn = outputVideo.open(<span class="string">&quot;Result003.avi&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>), <span class="number">10</span>,</span><br><span class="line">                 cv::Size((<span class="keyword">int</span>)cap.get(cv::CAP_PROP_FRAME_WIDTH),  (<span class="keyword">int</span>)cap.get(cv::CAP_PROP_FRAME_HEIGHT) ) , <span class="literal">true</span>);</span><br><span class="line">             <span class="keyword">if</span>(!rtn)</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//==【03】== 创建一个运动视频背景提取对象：分离背景和运动对象： 暂时未使用！</span></span><br><span class="line">         cv::Ptr&lt;cv::BackgroundSubtractorMOG2&gt; bgsubtractor= cv::createBackgroundSubtractorMOG2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==【04】== 命名两个显示窗口</span></span><br><span class="line">         cv::namedWindow(<span class="string">&quot;SRC&quot;</span>, <span class="number">0</span>);</span><br><span class="line">         cv::namedWindow(<span class="string">&quot;GREY&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==【05】== 循环读取视频</span></span><br><span class="line">         <span class="keyword">int</span> frameNums  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">double</span> t1 = (<span class="keyword">double</span>)cv::getCPUTickCount();</span><br><span class="line"></span><br><span class="line">         cap.read(frame);     <span class="comment">//读取一个视频帧</span></span><br><span class="line">         <span class="keyword">if</span>(frame.empty())</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(saveAVIenable)</span><br><span class="line">             outputVideo.write(frame);   <span class="comment">//写视频文件</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//==&gt;&gt; 取视频帧frame的一个矩形区，转换为灰度图像，存储到greyFrame</span></span><br><span class="line">         cv::cvtColor(frame(cv::Rect(<span class="number">0</span>, <span class="number">150</span>, frame.cols, frame.rows - <span class="number">150</span>)), greyFrame, cv::COLOR_RGB2GRAY);</span><br><span class="line">         <span class="comment">//==&gt;&gt; 将图像greyFrame的长宽分别缩小到1/2</span></span><br><span class="line">         cv::resize(greyFrame, greyFrame, cv::Size(greyFrame.cols/<span class="number">2</span>, greyFrame.rows/<span class="number">2</span>));</span><br><span class="line">         <span class="comment">//==&gt;&gt; 使用7*7卷积窗，平滑灰度图像greyFrame</span></span><br><span class="line">         cv::blur(greyFrame, greyFrame, cv::Size(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">         <span class="comment">// ==&gt;&gt; 计算处理时间</span></span><br><span class="line">         <span class="keyword">double</span> t2 = (<span class="keyword">double</span>)cv::getCPUTickCount();</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Line74 Video Play Delta Time = %.3fms\n&quot;</span>, <span class="number">1e0</span> * (t2 - t1)/(<span class="keyword">double</span>)cv::getTickFrequency());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// ==&gt;&gt; 显示处理结果</span></span><br><span class="line">         imshow(<span class="string">&quot;SRC&quot;</span>, frame);</span><br><span class="line">         <span class="keyword">if</span>(!greyFrame.empty())</span><br><span class="line">             imshow(<span class="string">&quot;GREY&quot;</span>, greyFrame);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// ==&gt;&gt; 按下键盘q退出</span></span><br><span class="line">         <span class="keyword">int</span> keycode = cv::waitKey(<span class="number">30</span>);</span><br><span class="line">         <span class="keyword">if</span>( keycode == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         frameNums++;</span><br><span class="line">         &#125;<span class="comment">//for</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(saveAVIenable)</span><br><span class="line">         outputVideo.release();</span><br><span class="line">    cap.release();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>VS 2019实际运行效果如下：</p></blockquote><p><fancybox><img src="https://i.loli.net/2020/03/06/3I7kzTpAmDMdueb.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/06/3I7kzTpAmDMdueb.png" srcset="data:image/png;base64,666" alt="4)LH$EDIZVJNC((AMUD1TZC.png"></fancybox></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV, 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学做图书管理系统--使用pyodbc和PyQt5连接前台GUI和后台SQL Server数据库</title>
      <link href="archives/ca06d6a5.html"/>
      <url>archives/ca06d6a5.html</url>
      
        <content type="html"><![CDATA[<p>这里主要记录了使用Python语言连接SQL Server的主要步骤和方法。 </p><a id="more"></a><p>在连接数据库之前，需要确保电脑上有以下环境和软件：</p><ul><li>（必备）任意一种数据库（这里选择SQL Server）</li><li>（必备）Python 3，可以在Python的<a href="https://www.python.org/">官网下载</a>对应的版本</li><li>（必备）任意一种代码编辑器或IDE（本教程使用的<strong>VS Code</strong>和<strong>SSMS</strong>两种，也可使用Python自带的IDLE或者Pycharm）</li><li>（可选）使用Python包管理器Anaconda，或者使用Python自带的pip</li></ul><h2 id="安装pyodbc"><a href="#安装pyodbc" class="headerlink" title="安装pyodbc"></a>安装pyodbc</h2><ol><li><p>首先，使用组合键<code>Win + R</code>调出<strong>运行</strong>窗口，输入<code>cmd</code>，打开命令行。</p></li><li><p>在命令行（CMD）界面，如使用了Anaconda，则需要激活conda环境（如没有Anaconda，则可以跳过这一步）：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate</span><br></pre></td></tr></table></figure><p>当光标前面出现了<code>(base) C:\Users\用户名&gt;</code>，则说明进入了conda的base环境。</p><ol start="3"><li>输入如下任意其中一种命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyodbc #常规方法，pip安装</span><br><span class="line">conda install pyodbc #如果安装了Anaconda，则可以使用conda命令</span><br></pre></td></tr></table></figure><p>当出现提示确认是否安装，输入<code>y</code>，则可以等待安装完成。</p><p><fancybox><img src="https://i.loli.net/2019/11/09/V9UckmeExLywRTr.png" class="lazyload" data-srcset="https://i.loli.net/2019/11/09/V9UckmeExLywRTr.png" srcset="data:image/png;base64,666" alt="install"></fancybox></p><h3 id="安装SQL-Server的ODBC驱动程序和命令行工具"><a href="#安装SQL-Server的ODBC驱动程序和命令行工具" class="headerlink" title="安装SQL Server的ODBC驱动程序和命令行工具"></a>安装SQL Server的ODBC驱动程序和命令行工具</h3><ol><li>进入微软的此页面下载安装<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=56567">ODBC驱动程序</a></li><li>进入微软的此页面下载安装<a href="https://www.microsoft.com/en-us/download/details.aspx?id=53591">命令行工具</a></li></ol><p>在命令行输入如下命令登录SQL Server：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlcmd <span class="literal">-S</span> localhost <span class="literal">-U</span> sa <span class="literal">-P</span> your_password</span><br><span class="line"><span class="number">1</span>&gt;    <span class="comment">#已登录成功</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学做图书管理系统--使用SQL Server创建并插入数据，建立触发器和存储过程</title>
      <link href="archives/6e81849.html"/>
      <url>archives/6e81849.html</url>
      
        <content type="html"><![CDATA[<p>数据库（Database）可以说是前端网站搭建必不可少的部分了。<br>常见的数据库软件有微软的SQL Server和Linux服务器中常见的MySQL两种。</p><p>|ू･ω･` )  </p><a id="more"></a><p>在连接数据库之前，需要确保电脑上有以下环境和软件：</p><ul><li>（必备）任意一种数据库（这里选择SQL Server）</li><li>（必备）Python 3，可以在Python的<a href="https://www.python.org/">官网下载</a>对应的版本</li><li>（必备）任意一种代码编辑器或IDE（本教程使用的<strong>VS Code</strong>和<strong>SSMS</strong>两种，也可使用Python自带的IDLE或者Pycharm）</li><li>（可选）使用Python包管理器Anaconda，或者使用Python自带的pip</li></ul><h2 id="安装SQL-Server"><a href="#安装SQL-Server" class="headerlink" title="安装SQL Server"></a>安装SQL Server</h2><blockquote><p>SQL Server可以从微软的官方网站上面下载获取：<br>链接：<a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads">https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads</a></p></blockquote><ol><li>我们可以选择免费的Express版本下载即可：</li></ol><p><img src="https://i.loli.net/2019/10/30/Xto8hRayGF6TVkW.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/Xto8hRayGF6TVkW.png" srcset="data:image/png;base64,666" alt="express"></p><ol start="2"><li>选择自定义安装：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/yufGT1ZUdXVcDBF.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/yufGT1ZUdXVcDBF.png" srcset="data:image/png;base64,666" alt="自定义"></fancybox></p><ol start="3"><li>选择下载到D盘，安装：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/qnxXTp9ifGswRUY.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/qnxXTp9ifGswRUY.png" srcset="data:image/png;base64,666" alt="D盘"></fancybox></p><p>这里需要稍等片刻：</p><p><fancybox><img src="https://i.loli.net/2019/10/30/v9YqAI4nbxoGZ5H.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/v9YqAI4nbxoGZ5H.png" srcset="data:image/png;base64,666" alt="wait"></fancybox></p><ol start="4"><li>下载后安装，选择<strong>全新的SQL Server安装</strong>：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/pi5h4zGfIuEjCOT.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/pi5h4zGfIuEjCOT.png" srcset="data:image/png;base64,666" alt="安装"></p><ol start="5"><li>然后依次按照图片所示一步步进行下去：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/ISheOuMWU18PHic.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/ISheOuMWU18PHic.png" srcset="data:image/png;base64,666" alt="1"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/uDNizGQ7Mm4UfEt.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/uDNizGQ7Mm4UfEt.png" srcset="data:image/png;base64,666" alt="2"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/yVPdNLTht2cfk7o.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/yVPdNLTht2cfk7o.png" srcset="data:image/png;base64,666" alt="3"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/G9DhC7K3JEWfbpg.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/G9DhC7K3JEWfbpg.png" srcset="data:image/png;base64,666" alt="4"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/PpKh5bxWw6H3TcC.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/PpKh5bxWw6H3TcC.png" srcset="data:image/png;base64,666" alt="5"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/u9EwZDAJ1jaKO6m.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/u9EwZDAJ1jaKO6m.png" srcset="data:image/png;base64,666" alt="6"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/dCWyU2FpiarwZeE.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/dCWyU2FpiarwZeE.png" srcset="data:image/png;base64,666" alt="7"></fancybox></p><p>稍微等待一会儿….</p><p><fancybox><img src="https://i.loli.net/2019/10/30/riXoEmYhDxcFLuN.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/riXoEmYhDxcFLuN.png" srcset="data:image/png;base64,666" alt="8"></fancybox></p><p>安装完成啦~</p><p><fancybox><img src="https://i.loli.net/2019/10/30/8hu1dGTQB9i7MjP.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/8hu1dGTQB9i7MjP.png" srcset="data:image/png;base64,666" alt="9"></fancybox></p><h3 id="安装SQL-Server管理工具（SSMS）"><a href="#安装SQL-Server管理工具（SSMS）" class="headerlink" title="安装SQL Server管理工具（SSMS）"></a>安装SQL Server管理工具（SSMS）</h3><blockquote><p>当我们安装了SSMS之后，便可以<strong>可视化</strong>地方便管理我们的数据库啦~  </p></blockquote><blockquote><p>其实，SSMS软件与Linux环境下管理MySQL数据库的phpMyAdmin功能挺类似的呐~  </p></blockquote><ol><li>首先，在SQL Server安装中心，选择第三项，安装<strong>SQL Server管理工具</strong>：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/DgYQbX1LaKVqk6M.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/DgYQbX1LaKVqk6M.png" srcset="data:image/png;base64,666" alt="10"></fancybox></p><ol start="2"><li>跳转到网页页面，选择最新的版本下载：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/FsNt7HIJjb3yRMv.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/FsNt7HIJjb3yRMv.png" srcset="data:image/png;base64,666" alt="11"></fancybox></p><ol start="3"><li>选择D盘安装，按照要求重启电脑：</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/30/fT1BK3SM6Ro5eJw.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/fT1BK3SM6Ro5eJw.png" srcset="data:image/png;base64,666" alt="12"></fancybox></p><p><fancybox><img src="https://i.loli.net/2019/10/30/59AgyjPEVKDp7mZ.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/30/59AgyjPEVKDp7mZ.png" srcset="data:image/png;base64,666" alt="13"></fancybox></p><ol start="4"><li>重启后，在开始菜单找到<strong>SQL Server Management Studio</strong>打开，并登陆就可以啦~</li></ol><p><fancybox><img src="https://i.loli.net/2019/10/31/uOH563TFWLjsq27.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/uOH563TFWLjsq27.png" srcset="data:image/png;base64,666" alt="14"></fancybox></p><h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>我们可以新建一个查询（数据库脚本）来创建一个数据库。  </p><p>登录进入SSMS后，选择菜单栏中的<code>新建查询</code>：</p><p><img src="https://i.loli.net/2019/11/08/SQcu73Y8CVfF2LH.png" class="lazyload" data-srcset="https://i.loli.net/2019/11/08/SQcu73Y8CVfF2LH.png" srcset="data:image/png;base64,666" alt="新建"></p><p>在SQL脚本中可以输入如下代码，例如我创建的存放数据的数据库和日志的数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> BookManageSys</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NAME</span> = <span class="string">&#x27;BookManageSys_Data&#x27;</span>,</span><br><span class="line">    FILENAME = <span class="string">&#x27;E:\Common_things\Programs\数据库SQL\BookManageSystem\BookManageSys.mdf&#x27;</span>,</span><br><span class="line">    <span class="keyword">SIZE</span> = <span class="number">10</span> MB,</span><br><span class="line">    <span class="keyword">MAXSIZE</span> = <span class="number">50</span> MB,</span><br><span class="line">    FILEGROWTH = <span class="number">5</span>%</span><br><span class="line">)</span><br><span class="line"><span class="keyword">LOG</span> <span class="keyword">ON</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NAME</span> = <span class="string">&#x27;BookManageSys_Log&#x27;</span>,</span><br><span class="line">    FILENAME = <span class="string">&#x27;E:\Common_things\Programs\数据库SQL\BookManageSystem\BookManageSys_Log.ldf&#x27;</span>,</span><br><span class="line">    <span class="keyword">SIZE</span> = <span class="number">2</span> MB,</span><br><span class="line">    <span class="keyword">MAXSIZE</span> = <span class="number">5</span> MB,</span><br><span class="line">    FILEGROWTH = <span class="number">1</span> MB</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><p>在T-SQL语法中，可以指定数据库的存放位置和其他约束和规则限制，只要在后面加上<code>NAME</code>和<code>FILENAME</code>参数即可。</p><hr><p>或者直接在数据库默认目录下创建：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> BookManageSys</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><p>然后在菜单栏点击<code>执行</code>，便可以创建一个数据库啦。</p><p><img src="https://i.loli.net/2019/11/08/7zyY5H2GShBrUdM.png" class="lazyload" data-srcset="https://i.loli.net/2019/11/08/7zyY5H2GShBrUdM.png" srcset="data:image/png;base64,666" alt="执行脚本"></p><h2 id="创建表、插入数据到表中"><a href="#创建表、插入数据到表中" class="headerlink" title="创建表、插入数据到表中"></a>创建表、插入数据到表中</h2><p>创建读者表、图书表和借阅表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TReader</span><br><span class="line">(</span><br><span class="line">    ReaderID <span class="built_in">char</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">Name</span> <span class="built_in">char</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    Sex   <span class="built_in">bit</span>    <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Born   <span class="built_in">date</span>  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Spec  <span class="built_in">char</span>(<span class="number">12</span>)  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">Num</span>  <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    Photo  varbinary(<span class="keyword">MAX</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TBook</span><br><span class="line">(</span><br><span class="line">    ISBN <span class="built_in">char</span>(<span class="number">18</span>)  <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    BookName <span class="built_in">char</span>(<span class="number">40</span>)  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Author <span class="built_in">char</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Publisher <span class="built_in">char</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Price <span class="built_in">float</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    CNum  <span class="built_in">int</span>   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Snum  <span class="built_in">int</span>   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Summary <span class="built_in">varchar</span>(<span class="number">200</span>),</span><br><span class="line">    Photo varbinary(<span class="keyword">MAX</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TLend</span><br><span class="line">(</span><br><span class="line">    BookID  <span class="built_in">char</span>(<span class="number">10</span>)  <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    ReaderID <span class="built_in">char</span>(<span class="number">8</span>)   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    ISBN  <span class="built_in">char</span>(<span class="number">18</span>)   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    Ltime datetime <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>向三个表中插入一些数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TReader</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;131101&#x27;</span>,<span class="string">&#x27;王林&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-2-10&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">4</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131102&#x27;</span>,<span class="string">&#x27;程明&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1997-2-1&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">2</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131103&#x27;</span>,<span class="string">&#x27;王燕&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1995-10-6&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131104&#x27;</span>,<span class="string">&#x27;韦严平&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-8-26&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">4</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131106&#x27;</span>,<span class="string">&#x27;李方方&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-11-20&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131107&#x27;</span>,<span class="string">&#x27;李明&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-5-1&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131108&#x27;</span>,<span class="string">&#x27;林一帆&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-8-5&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131109&#x27;</span>,<span class="string">&#x27;张强民&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-8-11&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131110&#x27;</span>,<span class="string">&#x27;张蔚&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1997-7-22&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131111&#x27;</span>,<span class="string">&#x27;赵琳&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1996-3-18&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131113&#x27;</span>,<span class="string">&#x27;严红&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1995-8-11&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131201&#x27;</span>,<span class="string">&#x27;王敏&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-6-10&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131202&#x27;</span>,<span class="string">&#x27;王林&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-1-29&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131203&#x27;</span>,<span class="string">&#x27;王玉民&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-3-26&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131204&#x27;</span>,<span class="string">&#x27;马琳琳&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1995-2-10&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131206&#x27;</span>,<span class="string">&#x27;李计&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-9-20&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131210&#x27;</span>,<span class="string">&#x27;李红庆&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-5-1&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131216&#x27;</span>,<span class="string">&#x27;孙祥欣&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1995-3-19&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131218&#x27;</span>,<span class="string">&#x27;孙研&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1996-10-9&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131220&#x27;</span>,<span class="string">&#x27;吴薇华&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1996-3-18&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131221&#x27;</span>,<span class="string">&#x27;刘燕敏&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1995-11-12&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;131241&#x27;</span>,<span class="string">&#x27;罗林琳&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1996-1-30&#x27;</span>,<span class="string">&#x27;通信工程&#x27;</span>,<span class="number">0</span>,<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TBook</span><br><span class="line"><span class="keyword">Values</span>(<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;MySQL实用教程（第2版）&#x27;</span>,<span class="string">&#x27;郑阿奇&#x27;</span>,<span class="string">&#x27;电子工业出版社&#x27;</span>,<span class="string">&#x27;53&#x27;</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;978-7-81124-476-2&#x27;</span>,<span class="string">&#x27;S7-300/400可编程控制器原理与应用&#x27;</span>,<span class="string">&#x27;崔维群 孙启法&#x27;</span>,<span class="string">&#x27;北京航空航天大学出版社&#x27;</span>,<span class="string">&#x27;59&#x27;</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;978-7-111-21382-6&#x27;</span>,<span class="string">&#x27;Java编程思想&#x27;</span>,<span class="string">&#x27;Bruce Eckel&#x27;</span>,<span class="string">&#x27;机械工业出版社&#x27;</span>,<span class="string">&#x27;108&#x27;</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;978-7-121-23402-6&#x27;</span>,<span class="string">&#x27;SQL Server实用教程（第4版）&#x27;</span>,<span class="string">&#x27;郑阿奇&#x27;</span>,<span class="string">&#x27;电子工业出版社&#x27;</span>,<span class="string">&#x27;59&#x27;</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;978-7-302-10853-6&#x27;</span>,<span class="string">&#x27;C程序设计（第三版）&#x27;</span>,<span class="string">&#x27;谭浩强&#x27;</span>,<span class="string">&#x27;清华大学出版社&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="literal">null</span>),</span><br><span class="line">(<span class="string">&#x27;978-7-121-20907-9&#x27;</span>,<span class="string">&#x27;C#实用教程（第2版）&#x27;</span>,<span class="string">&#x27;郑阿奇&#x27;</span>,<span class="string">&#x27;电子工业出版社&#x27;</span>,<span class="string">&#x27;49&#x27;</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> TLend </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;1200001&#x27;</span>,<span class="string">&#x27;131101&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-02-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1300001&#x27;</span>,<span class="string">&#x27;131101&#x27;</span>,<span class="string">&#x27;978-7-81124-476-2&#x27;</span>,<span class="string">&#x27;2014-02-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200002&#x27;</span>,<span class="string">&#x27;131102&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-02-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1400030&#x27;</span>,<span class="string">&#x27;131104&#x27;</span>,<span class="string">&#x27;978-7-121-23402-6&#x27;</span>,<span class="string">&#x27;2014-02-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1600011&#x27;</span>,<span class="string">&#x27;131101&#x27;</span>,<span class="string">&#x27;978-7-302-10853-6&#x27;</span>,<span class="string">&#x27;2014-02-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1700062&#x27;</span>,<span class="string">&#x27;131104&#x27;</span>,<span class="string">&#x27;978-7-121-20907-9&#x27;</span>,<span class="string">&#x27;2014-02-19&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200004&#x27;</span>,<span class="string">&#x27;131103&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-02-20&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200003&#x27;</span>,<span class="string">&#x27;131201&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-03-10&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1300002&#x27;</span>,<span class="string">&#x27;131202&#x27;</span>,<span class="string">&#x27;978-7-81124-476-2&#x27;</span>,<span class="string">&#x27;2014-03-11&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200005&#x27;</span>,<span class="string">&#x27;131204&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-03-11&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1400031&#x27;</span>,<span class="string">&#x27;131206&#x27;</span>,<span class="string">&#x27;978-7-121-23402-6&#x27;</span>,<span class="string">&#x27;2014-03-13&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1600013&#x27;</span>,<span class="string">&#x27;131203&#x27;</span>,<span class="string">&#x27;978-7-302-10853-6&#x27;</span>,<span class="string">&#x27;2014-03-13&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1700064&#x27;</span>,<span class="string">&#x27;131210&#x27;</span>,<span class="string">&#x27;978-7-121-20907-9&#x27;</span>,<span class="string">&#x27;2014-03-13&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1300003&#x27;</span>,<span class="string">&#x27;131216&#x27;</span>,<span class="string">&#x27;978-7-81124-476-2&#x27;</span>,<span class="string">&#x27;2014-03-13&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200007&#x27;</span>,<span class="string">&#x27;131218&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-04-08&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1800001&#x27;</span>,<span class="string">&#x27;131220&#x27;</span>,<span class="string">&#x27;978-7-111-21382-6&#x27;</span>,<span class="string">&#x27;2014-04-08&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1200008&#x27;</span>,<span class="string">&#x27;131221&#x27;</span>,<span class="string">&#x27;978-7-121-23270-1&#x27;</span>,<span class="string">&#x27;2014-04-08&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1400032&#x27;</span>,<span class="string">&#x27;131101&#x27;</span>,<span class="string">&#x27;978-7-121-23402-6&#x27;</span>,<span class="string">&#x27;2014-04-08&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1700065&#x27;</span>,<span class="string">&#x27;131102&#x27;</span>,<span class="string">&#x27;978-7-121-20907-9&#x27;</span>,<span class="string">&#x27;2014-04-08&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1600014&#x27;</span>,<span class="string">&#x27;131104&#x27;</span>,<span class="string">&#x27;978-7-302-10853-6&#x27;</span>,<span class="string">&#x27;2014-07-22&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1800002&#x27;</span>,<span class="string">&#x27;131104&#x27;</span>,<span class="string">&#x27;978-7-111-21382-6&#x27;</span>,<span class="string">&#x27;2014-07-22&#x27;</span>)</span><br></pre></td></tr></table></figure><p>插入完成后，可以使用<code>SELECT</code>语句查询一下我们插入的数据是否成功：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TReader</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TBook</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TLend</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS：</strong>如果使用VS Code编辑T-SQL脚本，可以参考微软的官方文档：<a href="https://docs.microsoft.com/zh-cn/sql/visual-studio-code/sql-server-develop-use-vscode?view=sql-server-ver15">使用 Visual Studio Code 创建并运行 Transact SQL 脚本</a></p></blockquote><h2 id="建立存储过程和触发器"><a href="#建立存储过程和触发器" class="headerlink" title="建立存储过程和触发器"></a>建立存储过程和触发器</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.microsoft.com/en-us/sql-server/developer-get-started/python/windows">在Windows上使用SQL Server创建Python应用</a></li><li><a href="https://github.com/mkleehammer/pyodbc/wiki">pyodbc Github 官网文档</a></li><li><a href="https://docs.microsoft.com/zh-cn/sql/visual-studio-code/sql-server-develop-use-vscode?view=sql-server-ver15">使用 Visual Studio Code 创建并运行 Transact SQL 脚本</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
            <tag> pyodbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学做图书管理系统--利用Python的PyQt5编写简单的GUI图形界面</title>
      <link href="archives/3b91e5f.html"/>
      <url>archives/3b91e5f.html</url>
      
        <content type="html"><![CDATA[<p>由于学校课程的项目，最近最近在学习如何利用Python语言和SQL Server编写一个读者图书借阅、查询管理的小程序。以此为契机吧，自己便开始了学习之路~<br>这篇文章主要介绍自己如何使用PyQt5编写GUI界面。  </p><a id="more"></a><h2 id="自己使用到的工具"><a href="#自己使用到的工具" class="headerlink" title="自己使用到的工具"></a>自己使用到的工具</h2><ul><li>VS Code</li><li>PyQt5依赖包</li><li>Qt Designer</li></ul><h2 id="Python几种常见的GUI库"><a href="#Python几种常见的GUI库" class="headerlink" title="Python几种常见的GUI库"></a>Python几种常见的GUI库</h2><h3 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h3><p>Tkinter是Python自带的量轻级的简单GUI库，使用也较为简单。但是Tkinter之适用于基础和小型程序的开发，界面的美观程度也相对有限。</p><p><strong>在网上找到了比较全面介绍Tkinter的使用教程</strong>：</p><ol><li><a href="https://www.cnblogs.com/shwee/p/9427975.html">https://www.cnblogs.com/shwee/p/9427975.html</a></li><li><a href="https://www.runoob.com/python/python-gui-tkinter.html">https://www.runoob.com/python/python-gui-tkinter.html</a></li></ol><h3 id="PyQt5"><a href="#PyQt5" class="headerlink" title="PyQt5"></a>PyQt5</h3><p>PyQt5算是比较成熟的GUI库了，PyQt从著名的由C++编写的Qt库移植封装到Python而来。同时，利用PyQt5开发GUI比较美观，同时利用<strong>Qt Designer</strong>可以拖动一些控件，实现GUI可视化的快速开发，可通过pyuic5工具转化为<code>.py</code>文件。在这里，自己选择了PyQt5开发前端界面。</p><h2 id="安装PyQt5和Qt-Designer"><a href="#安装PyQt5和Qt-Designer" class="headerlink" title="安装PyQt5和Qt Designer"></a>安装PyQt5和Qt Designer</h2><p>安装过程较为简单，只需在命令行窗口输入两行命令（在国内可以使用清华大学tuna镜像站，下载依赖包更快）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple  <span class="comment">#安装PyQt5</span></span><br><span class="line">pip install PyQt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple <span class="comment"># 安装Qt Designer</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><fancybox><img src="https://i.loli.net/2019/10/24/PFBobrTWEOkzQXK.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/24/PFBobrTWEOkzQXK.png" srcset="data:image/png;base64,666" alt="安装pyqt5-tools"></fancybox></p><p><strong>PS：若使用Anaconda，会省去很多环境配置步骤，这里只需安装PyQt5-tools即可，命令同上。</strong>如果想使用Anaconda，这里有详尽的配置及使用方法：<a href="https://blog.csdn.net/ITLearnHall/article/details/81708148">Anaconda详细安装及使用教程（带图文）</a></p><hr><p>安装成功后，Qt Designer会放在Python（或Anaconda）安装路径，即<code>安装路径\Python37\Lib\site-packages\pyqt5-tools\Qt\bin</code>或者<code>安装路径\Anaconda3\Lib\site-packages\pyqt5-tools\Qt\bin</code>中，找到<code>designer.exe</code>运行即可。</p><p><strong>PS：为了今后打开方便，可以创建一个快捷方式哦~</strong></p><p><fancybox><img src="https://i.loli.net/2019/10/24/XZRrHEde2uYvFhn.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/24/XZRrHEde2uYvFhn.png" srcset="data:image/png;base64,666" alt="找到designer"></fancybox></p><p>Qt Designer界面如下：</p><p><fancybox><img src="https://i.loli.net/2019/10/24/pu2IiGzkDenbyCJ.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/24/pu2IiGzkDenbyCJ.png" srcset="data:image/png;base64,666" alt="打开designer"></fancybox></p><p><strong>其中：</strong> 左栏为一些常用的一些控件，可以拖放到窗口里面；右栏为不同的控件的值的设定，选中对应的控件便可以编辑。</p><p><fancybox><img src="https://i.loli.net/2019/10/31/guvYLZ6CyVxdswq.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/guvYLZ6CyVxdswq.png" srcset="data:image/png;base64,666" alt="控件"></fancybox></p><blockquote><p><strong>关于Qt Designer的使用方法，可以自行找找度娘，使用方法很多啦~~这里放一个教程：</strong><a href="https://www.jianshu.com/nb/26159952">PyQt5速成教程</a></p></blockquote><h2 id="导出为-py文件"><a href="#导出为-py文件" class="headerlink" title="导出为.py文件"></a>导出为.py文件</h2><blockquote><p>当我们按照自己的需求，设计好了相关的界面后，便可以导入成<code>.py</code>文件啦~</p></blockquote><p>设计保存后，桌面上会有一个<code>.ui</code>文件，这个就是Qt Designer生成的XML格式的文件。</p><p><img src="https://i.loli.net/2019/10/31/MLTOtmrXivhP3GH.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/MLTOtmrXivhP3GH.png" srcset="data:image/png;base64,666" alt=".ui"></p><p>这里，我们使用<code>pyuic5</code>这个插件转换文件格式。转到这个文件夹目录后，在命令行窗口输入如下格式命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 - o 目标文件名.py 源文件名.ui</span><br></pre></td></tr></table></figure><p>如我的这样做的：</p><p><img src="https://i.loli.net/2019/10/31/k4U1hIdCz9sNBVD.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/k4U1hIdCz9sNBVD.png" srcset="data:image/png;base64,666" alt="cmd"></p><p>此时，会发现，文件夹多了一个转换后的同名<code>.py</code>文件：</p><p><img src="https://i.loli.net/2019/10/31/uFjVr2PlYImLR3N.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/uFjVr2PlYImLR3N.png" srcset="data:image/png;base64,666" alt="同名文件"></p><p>打开<code>SetupUi.py</code>文件，发现里面代码很长，但是已经<strong>自动生成</strong>了，这样少了很多敲代码的步骤呢~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Form implementation generated from reading ui file &#x27;SetupUi.ui&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Created by: PyQt5 UI code generator 5.13.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING! All changes made in this file will be lost!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui_mainWindow</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span>(<span class="params">self, mainWindow</span>):</span></span><br><span class="line">        mainWindow.setObjectName(<span class="string">&quot;mainWindow&quot;</span>)</span><br><span class="line">        mainWindow.resize(<span class="number">561</span>, <span class="number">491</span>)</span><br><span class="line">        mainWindow.setAnimated(<span class="literal">False</span>)</span><br><span class="line">        self.centralwidget = QtWidgets.QWidget(mainWindow)</span><br><span class="line">        self.centralwidget.setObjectName(<span class="string">&quot;centralwidget&quot;</span>)</span><br><span class="line">        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)</span><br><span class="line">        self.verticalLayout.setObjectName(<span class="string">&quot;verticalLayout&quot;</span>)</span><br><span class="line">        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)</span><br><span class="line">        self.tabWidget.setObjectName(<span class="string">&quot;tabWidget&quot;</span>)</span><br><span class="line">        self.tab = QtWidgets.QWidget()</span><br><span class="line">        self.tab.setObjectName(<span class="string">&quot;tab&quot;</span>)</span><br><span class="line">        self.formLayout = QtWidgets.QFormLayout(self.tab)</span><br><span class="line">        self.formLayout.setObjectName(<span class="string">&quot;formLayout&quot;</span>)</span><br><span class="line">        self.label1 = QtWidgets.QLabel(self.tab)</span><br><span class="line">        self.label1.setObjectName(<span class="string">&quot;label1&quot;</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">0</span>, QtWidgets.QFormLayout.FieldRole, self.label1)</span><br><span class="line">        self.graphicsView = QtWidgets.QGraphicsView(self.tab)</span><br><span class="line">        brush = QtGui.QBrush(QtGui.QColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        brush.setStyle(QtCore.Qt.NoBrush)</span><br><span class="line">        self.graphicsView.setBackgroundBrush(brush)</span><br><span class="line">        self.graphicsView.setObjectName(<span class="string">&quot;graphicsView&quot;</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">3</span>, QtWidgets.QFormLayout.FieldRole, self.graphicsView)</span><br><span class="line">        self.buttonBox = QtWidgets.QDialogButtonBox(self.tab)</span><br><span class="line">        self.buttonBox.setStatusTip(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.buttonBox.setAccessibleName(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)</span><br><span class="line">        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Close|QtWidgets.QDialogButtonBox.Ok)</span><br><span class="line">        self.buttonBox.setCenterButtons(<span class="literal">False</span>)</span><br><span class="line">        self.buttonBox.setObjectName(<span class="string">&quot;buttonBox&quot;</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">4</span>, QtWidgets.QFormLayout.FieldRole, self.buttonBox)</span><br><span class="line">        self.frame = QtWidgets.QFrame(self.tab)</span><br><span class="line">        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)</span><br><span class="line">        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)</span><br><span class="line">        self.frame.setObjectName(<span class="string">&quot;frame&quot;</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">5</span>, QtWidgets.QFormLayout.LabelRole, self.frame)</span><br><span class="line">        self.tabWidget.addTab(self.tab, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.tab_2 = QtWidgets.QWidget()</span><br><span class="line">        self.tab_2.setObjectName(<span class="string">&quot;tab_2&quot;</span>)</span><br><span class="line">        self.tabWidget.addTab(self.tab_2, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.verticalLayout.addWidget(self.tabWidget)</span><br><span class="line">        mainWindow.setCentralWidget(self.centralwidget)</span><br><span class="line">        self.menubar = QtWidgets.QMenuBar(mainWindow)</span><br><span class="line">        self.menubar.setGeometry(QtCore.QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">561</span>, <span class="number">23</span>))</span><br><span class="line">        self.menubar.setObjectName(<span class="string">&quot;menubar&quot;</span>)</span><br><span class="line">        self.menu_options = QtWidgets.QMenu(self.menubar)</span><br><span class="line">        self.menu_options.setObjectName(<span class="string">&quot;menu_options&quot;</span>)</span><br><span class="line">        self.menu_about = QtWidgets.QMenu(self.menubar)</span><br><span class="line">        self.menu_about.setObjectName(<span class="string">&quot;menu_about&quot;</span>)</span><br><span class="line">        mainWindow.setMenuBar(self.menubar)</span><br><span class="line">        self.statusbar = QtWidgets.QStatusBar(mainWindow)</span><br><span class="line">        self.statusbar.setObjectName(<span class="string">&quot;statusbar&quot;</span>)</span><br><span class="line">        mainWindow.setStatusBar(self.statusbar)</span><br><span class="line">        self.action = QtWidgets.QAction(mainWindow)</span><br><span class="line">        self.action.setCheckable(<span class="literal">False</span>)</span><br><span class="line">        self.action.setWhatsThis(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.action.setShortcutContext(QtCore.Qt.WindowShortcut)</span><br><span class="line">        self.action.setObjectName(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">        self.action_2 = QtWidgets.QAction(mainWindow)</span><br><span class="line">        self.action_2.setShortcutContext(QtCore.Qt.ApplicationShortcut)</span><br><span class="line">        self.action_2.setMenuRole(QtWidgets.QAction.QuitRole)</span><br><span class="line">        self.action_2.setObjectName(<span class="string">&quot;action_2&quot;</span>)</span><br><span class="line">        self.menu_options.addAction(self.action_2)</span><br><span class="line">        self.menu_about.addAction(self.action)</span><br><span class="line">        self.menubar.addAction(self.menu_options.menuAction())</span><br><span class="line">        self.menubar.addAction(self.menu_about.menuAction())</span><br><span class="line"></span><br><span class="line">        self.retranslateUi(mainWindow)</span><br><span class="line">        self.tabWidget.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line">        QtCore.QMetaObject.connectSlotsByName(mainWindow)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retranslateUi</span>(<span class="params">self, mainWindow</span>):</span></span><br><span class="line">        _translate = QtCore.QCoreApplication.translate</span><br><span class="line">        mainWindow.setWindowTitle(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;MainWindow&quot;</span>))</span><br><span class="line">        self.tabWidget.setToolTip(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>))</span><br><span class="line">        self.label1.setText(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;学生图书管理系统&quot;</span>))</span><br><span class="line">        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;Tab 1&quot;</span>))</span><br><span class="line">        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;Tab 2&quot;</span>))</span><br><span class="line">        self.menu_options.setTitle(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;选项&quot;</span>))</span><br><span class="line">        self.menu_about.setTitle(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;关于&quot;</span>))</span><br><span class="line">        self.action.setText(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;关于作者&quot;</span>))</span><br><span class="line">        self.action_2.setText(_translate(<span class="string">&quot;mainWindow&quot;</span>, <span class="string">&quot;退出&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用VS-Code编写基础程序"><a href="#使用VS-Code编写基础程序" class="headerlink" title="使用VS Code编写基础程序"></a>使用VS Code编写基础程序</h2><p>使用VS Code打开这个文件夹，秉承界面和其他操作分离的原则，我们可以新建一个<code>.py</code>文件，如命名为<code>ConnetDatabase.py</code>，从而调用刚才生成的界面模块，新建一个<code>MyWindow</code>的子类，继承于<code>QMainWindow</code>和<code>Ui_mainWindow</code>父类，并初始化，编写构造函数即可。</p><p>最后，创建一个名为<code>myWin</code>的对象，启动即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow  <span class="comment">#导入PyQt相关模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>  SetupUi <span class="keyword">import</span> *  <span class="comment">#导入之前新生成的窗口模块</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span>(<span class="params">QMainWindow, Ui_mainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=None</span>):</span></span><br><span class="line">        super(MyWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    myWin = MyWindow()  <span class="comment">#创建对象</span></span><br><span class="line">    myWin.show()    <span class="comment">#显示窗口</span></span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的效果如图：</p><p><img src="https://i.loli.net/2019/10/31/cjeohUJV6giNySr.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/31/cjeohUJV6giNySr.png" srcset="data:image/png;base64,666" alt="运行"></p><blockquote><p><strong>至此，基本的窗口创建成功，便可以开始写后端的具体代码实现了~</strong></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/weixin_37773766/article/details/81535876">八款常用的 Python GUI 开发框架推荐</a></li><li><a href="https://blog.csdn.net/weixin_41929524/article/details/81456308">Python制作小软件——1. 安装并使用PyQt5进行界面设计</a></li><li><a href="https://doc-snapshots.qt.io/qt5-dev/designer-to-know.html#">Qt官网——Getting to Know Qt Designer</a></li><li><a href="https://doc-snapshots.qt.io/qt5-dev/qtdesigner-manual.html">Qt官网——Qt Designer Manual</a></li><li><a href="https://blog.51cto.com/9291927/2422187">PyQt5快速入门（二）PyQt5信号槽机制</a></li><li><a href="http://code.py40.com/1948.html">【第一节】PyQt5简介</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
          <category> 图形界面 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyQt </tag>
            
            <tag> GUI </tag>
            
            <tag> Qt Designer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内外常用VPS + 域名注册 + CDN，搭建属于自己的博客（新手推荐）</title>
      <link href="archives/d874e9c.html"/>
      <url>archives/d874e9c.html</url>
      
        <content type="html"><![CDATA[<p>本文大概概括总结了自己学习前端技术以来各种实用的VPS、域名注册以及实用的CDN提供商。<br>特别是对于<strong>新手</strong>来说，了解一些相关知识挺不容易的。<br>写一些总结希望会对大家有一定的帮助吧。<strong>本文章会不定时更新</strong>，分享更多的实用选择喔~  </p><p>喜欢的话就继续往下看看吧(<em>/ω＼</em>)  </p><a id="more"></a><h2 id="建站VPS（虚拟专用服务器）"><a href="#建站VPS（虚拟专用服务器）" class="headerlink" title="建站VPS（虚拟专用服务器）"></a>建站VPS（虚拟专用服务器）</h2><p>对于一个网站来说，首先需要的便是一台服务器（VPS）。可以有国内和境外两个选择。</p><h3 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h3><p>对于国内用户来说，常见VPS有如下几家提供商：  </p><ul><li><a href="https://www.aliyun.com/">阿里云</a>：算是国内最为知名的服务器提供商了，安全且稳定。</li><li><a href="https://cloud.tencent.com/">腾讯云</a>：第二大云服务提供商，微信小程序使用较为普遍。</li><li><a href="https://www.huaweicloud.com/">华为云</a>：使用也比较普遍。</li><li><a href="https://www.ucloud.cn/">UCLOUD</a></li></ul><blockquote><p>几家服务商提供的VPS价格均相差不远，其中，阿里云和腾讯云对于在校大学生有优惠活动：  </p></blockquote><p><strong>阿里云</strong>：“云翼计划”，点击<a href="https://promotion.aliyun.com/ntms/act/campus2018.html">这里</a>进入优惠网址。  </p><p>阿里云优惠需要通过学生认证，注册账号后，在后台账号管理界面可以申请认证：  </p><p><fancybox><img src="https://i.loli.net/2019/10/10/YcAqefmvkDKTyn8.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/YcAqefmvkDKTyn8.png" srcset="data:image/png;base64,666" alt="学生优惠"></fancybox></p><p>认证后，对于学生机的量轻服务器和ECS仅<strong>9.5 RMB/月</strong>！！！！！</p><p><fancybox><img src="https://i.loli.net/2019/10/10/iRKEZmJ6A3hxjpn.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/iRKEZmJ6A3hxjpn.png" srcset="data:image/png;base64,666" alt="aliyun"></fancybox></p><hr><p><strong>腾讯云</strong>：名称也类似，“云+校园”，优惠网址入口点击<a href="https://cloud.tencent.com/act/campus">这里</a>。</p><p>腾讯云25岁以下或者通过学生认证直接优惠，不仅可以购买优惠价的云服务器，还可以购买优惠价的MySQL数据库：</p><p><fancybox><img src="https://i.loli.net/2019/10/10/BXTZnwVQNJWIfhD.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/BXTZnwVQNJWIfhD.png" srcset="data:image/png;base64,666" alt="qcloud"></fancybox></p><p>腾讯云也相当的很便宜，仅仅<strong>10 RMB/月</strong>！！！</p><h3 id="境外"><a href="#境外" class="headerlink" title="境外"></a>境外</h3><p>对于境外的可选择的提供商就比较多了。如亚马逊的AWS，微软的Azure，谷歌的Google Cloud，IBM公司的Cloud等等…但是国外的VPS换算为RMB后普遍偏贵，博主实在买不起呜呜呜(T＿T)  </p><hr><p>这里，博主只能选择境外廉价的VPS提供商了。如<a href="https://virmach.com/">VirMarch</a>、<a href="https://vultr.com/">Vultr</a>、<a href="https://www.linode.com/">linode</a>和<a href="https://bwh88.net/">搬瓦工Bandwagon</a>。  </p><p>对于此类廉价VPS，官方常常有一些<strong>优惠减价活动</strong>，可以国内相关的中文社区看看：</p><ul><li><a href="https://virmach.net/">VirMach中文网</a></li><li><a href="https://www.cnvultr.com/">Vultr中文网</a></li><li><a href="https://banwagong.cn/">搬瓦工VPS中文网1</a></li></ul><p><strong>PS</strong>：由于这类VPS廉价，最低只需2-4美元/月，因此，其提供的相关服务支持有限，有些服务器访问速度较慢（<strong>但这并不是问题，可以配合Cloudflare的CDN加速使用</strong>），最好不要用于重要用途。主要推荐国内的阿里云和腾讯云。</p><p><strong>PS：这里不介绍如何购买VPS，自己可以找找度娘，网上有很多教程~</strong></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>有了VPS之后，便需要注册一个域名来来指向自己的VPS，使得大家都方便访问。</p><h3 id="域名注册商"><a href="#域名注册商" class="headerlink" title="域名注册商"></a>域名注册商</h3><p>对于域名注册商来说，也有挺多的选择，<strong>国内</strong>可以选择：  </p><ul><li><a href="http://www.net.cn/">万网（被阿里云收购）</a></li><li><a href="http://www.xinnet.com/">新网（与腾讯云有合作关系）</a></li><li><a href="https://www.ename.net/">易名</a></li><li>…</li></ul><p><strong>PS</strong>：对于国内的域名注册来说，其域名后缀类型有限（<code>.com</code>，<code>.cn</code>，<code>.net</code>，<code>.top</code>，<code>.xyz</code>等常见域名），如果域名需要<strong>备案</strong>，其支持的格式也相当有限制了，只有部分少量域名类型才能备案。</p><hr><p>如果对其他类型的域名，如<code>.me</code>，<code>.io</code>, <code>.cc</code>，<code>.design</code>或者其他顶级国家域名的时候，就需要找找<strong>国外</strong>老牌的注册商了，如：</p><ul><li>Namecheap</li><li>Godaddy</li><li>NameSilo</li><li>Name.com</li><li>…</li></ul><h3 id="NameBeta-com"><a href="#NameBeta-com" class="headerlink" title="NameBeta.com"></a>NameBeta.com</h3><p>国外的域名注册商十分繁多，网站地址也很难记忆，不同注册商价格不一，英文界面对于国人来说不太友好。因此，这里推荐一个域名统一搜索平台——**<a href="https://namebeta.com/">NameBeta.com</a>**</p><hr><p>此平台是国内知名博客程序<a href="http://typecho.org/">Typecho</a>创始人joyqi又一个作品<del>~</del></p><p>NameBeta.com汇集了国内外大量知名注册商的数据，并列出各个域名和注册商的最近优惠，我们只需要在搜索框输入自己想注册的域名后，便会自动得出注册<strong>最为划算</strong>的域名提供商，<strong>点击后会自动跳转到对应注册商的付款页面！！！！</strong>，相当方便有木有！！！！</p><p><fancybox><img src="https://i.loli.net/2019/10/10/m1xnN8Ewslo3T9L.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/m1xnN8Ewslo3T9L.png" srcset="data:image/png;base64,666" alt="namebeta"></fancybox></p><hr><p>此外，对于Chrome浏览器来说，还支持安装插件！！！在页面最下方可进入安装：</p><p><fancybox><img src="https://i.loli.net/2019/10/10/SgA1aVEZIxyf6nQ.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/SgA1aVEZIxyf6nQ.png" srcset="data:image/png;base64,666" alt="插件"></fancybox></p><p>这样，可以不用每次进入网站直接在浏览器插件寻找自己心仪的域名啦！</p><p><strong>例如：</strong><br>我的博客域名<a href="https://sublimerui.top/">sublimerui.top</a>和<a href="https://cwxyr.me/">cwxyr.me</a>便是通过NameBeta.com检索后，分别在万网和Godaddy注册的。</p><p><strong>最后，在此感谢joyqi大佬~</strong></p><p><strong>PS：域名的注册方法也可以自行找找度娘滴~</strong></p><h2 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h2><p>对于个人博客来说，使用CDN可以说是一个非常常见的配备了。<br>CDN（内容分发网络）是一种用来减轻服务器压力的常见方法，利用附近节点就近推送下载文件的原则，可以缩短网页访问速度。  </p><h3 id="国内-1"><a href="#国内-1" class="headerlink" title="国内"></a>国内</h3><p>CDN可以分为多种：  </p><ul><li>用于储存图片的CDN（图床，自己经常使用）：<code>sm.ms</code>，<code>img.vim-cn.com</code>等等…</li><li>用于储存大型文件的OSS加CDN：<a href="https://www.qiniu.com/">七牛云</a>，<a href="https://www.upyun.com/">又拍云</a>（<strong>提供免费OSS储存空间</strong>），阿里云，腾讯云（OSS与CDN均需要花钱）等等…</li></ul><p>其中，又拍云推出的开发者帮助计划 <strong><a href="https://www.upyun.com/league">又拍云联盟</a>**，可以在线申请</strong>10GB免费储存空间和15GB免费CDN流量**，有兴趣的朋友可以去看看呀~</p><p><img src="https://i.loli.net/2019/10/14/yUkfSX1mVGHq7dl.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/14/yUkfSX1mVGHq7dl.png" srcset="data:image/png;base64,666" alt="upyun"></p><h3 id="境外-1"><a href="#境外-1" class="headerlink" title="境外"></a>境外</h3><p>对于个人博客来说，境外的服务器确实也不便宜，但唯一的优点便是<strong>不用对域名进行备案</strong>，直接在域名解析处使用<code>A记录</code>将域名指向境外的服务器的IP即可。这类极力推荐挂一个CDN，不然会慢死（<del>由于中国的GFW存在，会对一些内容进行过滤和封锁，这也是为什么有科学上网的说法</del>）</p><p>这里，可以使用<code>Cloudflare</code>进行网站的加速，国人很多都是用Cloudflare加速境外的服务器的访问。（<strong>真的挺好用的！</strong>）</p><p><img src="https://i.loli.net/2019/10/10/WMB9GpyjRL5lvXr.png" class="lazyload" data-srcset="https://i.loli.net/2019/10/10/WMB9GpyjRL5lvXr.png" srcset="data:image/png;base64,666" alt="cloudflare"></p><p>这里放几篇自己认为比较好用的Cloudflare使用教程，讲得比较详细：</p><ol><li><a href="https://cloud.tencent.com/developer/news/135302">十个你可能不知道的CloudFlare免费CDN加速技巧-SSL\DDOS\Cache</a></li><li><a href="http://wenda.dreamshare.in/article_12.html">使用CloudFlare加速和保护你的境外网站</a></li><li><a href="https://www.jianshu.com/p/24d3800f597a">Cloudflare 免费SSL证书使用</a></li><li><a href="https://www.cnblogs.com/waw/p/5729722.html">CloudFlare CDN折腾记－优化设置</a></li></ol><blockquote><p>未完待续，关于这方面的总结有新的内容会持续更新滴~</p></blockquote><hr><p>很久都没更新文章了(╥╯^╰╥)鸽了一个月了吧…最近确实有点小忙，呜呜呜… </p><p><strong>感谢你的耐心阅读呀(๑<em>◡</em>๑)，总结不易，加个收藏点点赞呗~</strong></p><p><strong>你的支持就是我前进的动力呀~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> 域名 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]计算机四级网络工程师思维导图--计算机网络部分</title>
      <link href="archives/5be6111c.html"/>
      <url>archives/5be6111c.html</url>
      
        <content type="html"><![CDATA[<p>计算机四级网络工程师考试快开始了。<br>这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~</p><p>此部分为<strong>计算机网络</strong>部分~</p><a id="more"></a><p><strong>PS:</strong></p><ul><li><strong>思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~</strong></li><li><strong>图片高清，但文字较小也很长，可以点击图片后放大学习哦~</strong></li></ul><h2 id="一、网络技术基础"><a href="#一、网络技术基础" class="headerlink" title="一、网络技术基础"></a>一、网络技术基础</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/2JryQt6se1VnRdi.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/2JryQt6se1VnRdi.jpg" srcset="data:image/png;base64,666" alt="1"></fancybox></p><h2 id="二、局域网基础"><a href="#二、局域网基础" class="headerlink" title="二、局域网基础"></a>二、局域网基础</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/IyXO1pNlzZwA72i.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/IyXO1pNlzZwA72i.jpg" srcset="data:image/png;base64,666" alt="2"></fancybox></p><h2 id="三、Internet基础"><a href="#三、Internet基础" class="headerlink" title="三、Internet基础"></a>三、Internet基础</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/WyxAHXO9k3RoY1L.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/WyxAHXO9k3RoY1L.jpg" srcset="data:image/png;base64,666" alt="3"></fancybox></p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，总结不易，收藏点个赞呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
          <category> 计算机考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机四级 </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]计算机四级网络工程师思维导图--操作系统部分</title>
      <link href="archives/55ffe23a.html"/>
      <url>archives/55ffe23a.html</url>
      
        <content type="html"><![CDATA[<p>计算机四级网络工程师考试快开始了。<br>这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~</p><p>此部分为<strong>操作系统</strong>部分~</p><a id="more"></a><p><strong>PS:</strong></p><ul><li><strong>思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~</strong></li><li><strong>图片高清，但文字较小也很长，可以点击图片后放大学习哦~</strong></li></ul><h2 id="一、操作系统原理"><a href="#一、操作系统原理" class="headerlink" title="一、操作系统原理"></a>一、操作系统原理</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/i2nB7ZWGboSfLJ6.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/i2nB7ZWGboSfLJ6.jpg" srcset="data:image/png;base64,666" alt="1"></fancybox></p><h2 id="二、操作系统运行机制"><a href="#二、操作系统运行机制" class="headerlink" title="二、操作系统运行机制"></a>二、操作系统运行机制</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/RhEFcGeubBZsvyT.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/RhEFcGeubBZsvyT.jpg" srcset="data:image/png;base64,666" alt="2"></fancybox></p><h2 id="三、进程线程模型"><a href="#三、进程线程模型" class="headerlink" title="三、进程线程模型"></a>三、进程线程模型</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/TpiU35SIucmV7L2.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/TpiU35SIucmV7L2.jpg" srcset="data:image/png;base64,666" alt="3"></fancybox></p><h2 id="四、并发与同步"><a href="#四、并发与同步" class="headerlink" title="四、并发与同步"></a>四、并发与同步</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/tEs2S7L1krHePaf.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/tEs2S7L1krHePaf.jpg" srcset="data:image/png;base64,666" alt="4"></fancybox></p><h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/nTuzLJ4BwjgO6kV.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/nTuzLJ4BwjgO6kV.jpg" srcset="data:image/png;base64,666" alt="5"></fancybox></p><h2 id="六、文件管理"><a href="#六、文件管理" class="headerlink" title="六、文件管理"></a>六、文件管理</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/yZqHEWBv5VOPhoL.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/yZqHEWBv5VOPhoL.jpg" srcset="data:image/png;base64,666" alt="6"></fancybox></p><h2 id="七、I-O设备管理"><a href="#七、I-O设备管理" class="headerlink" title="七、I/O设备管理"></a>七、I/O设备管理</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/gUtzhmMWeKxjXkN.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/gUtzhmMWeKxjXkN.jpg" srcset="data:image/png;base64,666" alt="7"></fancybox></p><h2 id="八、死锁"><a href="#八、死锁" class="headerlink" title="八、死锁"></a>八、死锁</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/RZ8PYoJdaj9GEWL.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/RZ8PYoJdaj9GEWL.jpg" srcset="data:image/png;base64,666" alt="8"></fancybox></p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，总结不易，收藏点个赞呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
          <category> 计算机考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机四级 </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]计算机四级网络工程师思维导图--常考重点</title>
      <link href="archives/767f2af2.html"/>
      <url>archives/767f2af2.html</url>
      
        <content type="html"><![CDATA[<p>计算机四级网络工程师考试快开始了。<br>这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~</p><p>此部分为整体归纳出来的<strong>常考重点</strong>~</p><a id="more"></a><p><strong>PS:</strong></p><ul><li><strong>思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~</strong></li><li><strong>图片高清，但文字较小也很长，可以点击图片后放大学习哦~</strong></li></ul><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/9e5KGYR4mMOh6r1.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/9e5KGYR4mMOh6r1.jpg" srcset="data:image/png;base64,666" alt="操作系统"></fancybox></p><h2 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a>二、计算机网络</h2><p><fancybox><img src="https://i.loli.net/2019/09/07/zGM6RVNHABSs3ca.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/zGM6RVNHABSs3ca.jpg" srcset="data:image/png;base64,666" alt="计算机网络"></fancybox></p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，总结不易，收藏点个赞呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
          <category> 计算机考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机四级 </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机四级网络工程师知识点（非常全面！）</title>
      <link href="archives/e78192a8.html"/>
      <url>archives/e78192a8.html</url>
      
        <content type="html"><![CDATA[<p>马上计算机考试了呢。相关的四级网络工程师的知识点也很重要呀~<br>自己从网上下载并花时间整理了相关的资料，下面内容是经过总结而成~请放心食用！</p><p><strong>PS:以下内容为长文档，内容很多，建议配合文章目录学习哦</strong></p><p><img src="https://i.loli.net/2019/09/07/YfAtDR2JnWeXMFE.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/09/07/YfAtDR2JnWeXMFE.jpg" srcset="data:image/png;base64,666" alt="cover"></p><a id="more"></a><h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a><center>操作系统原理</center></h1><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a><center>一、操作系统概述</center></h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h3><p>（1）概念</p><p>是计算机系统的一个系统软件，能有效地组织和管理计算机系统中的硬件和软件资源，合理（公平对待不同用户程序，不发生“死锁”和“饥饿”）组织计算机工作流程，控制程序的执行，并向用户提供各种服务功能，使用户能灵活、方便、有效地使用计算机，并使整个计算机系统高效运行；位于硬件之上，支撑软件（软件的编制和维护）之下。</p><p>A.应用角度看主要作用：提供人机交互接口（提供给用户的接口是命令输入和系统调用）；<br>B.软件开发角度看作用：软件开发的基础平台；<br>C.安全保护角度看作用：第一道安全防线；<br>D.系统发展角度看作用：虚拟机和扩展机  </p><p>（2）特性</p><p>A.并发性：执行期间具有相互制约关系；程序与计算不再一一对应；结果不再现并发过程失去封闭性；<br>B.共享性：CPU、内外存储器、外部设备；<br>C.随机性（异步性）：何时退出？假死？中断？关机？重启？  </p><p>（3）功能</p><p>A.进程管理：对CPU进行管理。包括进程控制（创建、撤销结束进程以及控制运行时候的各种状态转换）、进程同步（处理进程之间同步或互斥关系）、进程间通信（信息交换）和进程调度（按照一定算法从就绪队列中挑选一个进程让CPU执行它）；<br>B.存储管理：管理计算机内存资源。包括回收与分配内存、存储保护（考虑程序可能发生越界的情况）和内存扩充（借助虚拟技术在逻辑上增加进程运行空间）；<br>C.文件管理：文件存储空间的管理（管理/创建/删除/命名文件）；文件目录管理；文件系统的安全性（读写和存取权限）<br>D.设备管理：除CPU和内存之外的所有输入输入设备，复杂外部设备分配和故障处理。技术包括：中断技术、通道技术、虚拟设备技术和缓冲技术。<br>E.用户接区（作业管理）：  </p><p>（4）常见的操作系统</p><p>Ubuntu、Windows、Unix、DOS、BSD  </p><h3 id="2-操作系统分类"><a href="#2-操作系统分类" class="headerlink" title="2.操作系统分类"></a>2.操作系统分类</h3><p><strong>按页面使用环境和功能特征</strong></p><p>（1）批处理系统：分单道批处理系统和多道批处理系统，其中多道批处理效率和吞吐量较高但缺少人机交互性；指令有特权指令和一般指令；<br>（2）分时系统：多用户共同、交互使用系统；独占性（用户感觉）；及时性<br>（3）实时系统：多路性，及时性，交互性，可靠性，有过载防护能力  </p><p><strong>按计算机体系结构分类</strong></p><p>（1）个人操作系统<br>（2）网络操作系统：主从关系明显；有限制共享资源；<br>（3）分布式操作系统：统一配置，所有主机使用一个操作系统；资源共享；相互通信；<br>（4）嵌入式操作系统：成本低<br>交互式系统是指用户交互式地向系统提出命令请求，系统接受每个用户的命令，采用时间片轮转方式处理服务，并通过交互方式在终端上向用户显示结果。多级反馈、时间片轮转和高优先级适用于交互式操作系统。</p><h3 id="3-操作系统结构"><a href="#3-操作系统结构" class="headerlink" title="3.操作系统结构"></a>3.操作系统结构</h3><p>（1）整体式结构：功能划分成多模块；<br>（2）层次式结构：单向调用，同层不调用；<br>（3）微内核结构（C/S结构）：将大多数的操作系统由用户进程实现；分割成多个部分，每一部分只处理一方面的功能，如文件服务、进程服务与服务器通信；特点：高可靠性、高灵活性、适合分布式处理、可移植性强、融入面向对象技术，但效率低，不适合频繁通信；微内核具备：线程调度、虚拟存储、消息传递、设备驱动、内核原语操作以及中断处理。</p><h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h3><p>（1）特权指令：包括输出指令、停机指令等，只有在监控程序才能执行特权指令，只能在内核状态（管态）下运行（屏蔽中断、关闭中断）；<br>（2）一般指令：用户态下运行（关机、读文件、设置时间），管态下也可以执行。如果用户程序在用户态（目态）执行特权指令，则引起访管中断，这也是CPU由用户态向核心态转换的方法。</p><h3 id="5-临界资源、可重写入代码和不可重用资源"><a href="#5-临界资源、可重写入代码和不可重用资源" class="headerlink" title="5.临界资源、可重写入代码和不可重用资源"></a>5.临界资源、可重写入代码和不可重用资源</h3><p>（1）临界资源：<br>（2）可重写入代码：硬盘，内存；<br>（3）不可重用资源：时间片到时、硬件时钟到时  </p><h3 id="6-三类接口可供用户使用"><a href="#6-三类接口可供用户使用" class="headerlink" title="6.三类接口可供用户使用"></a>6.三类接口可供用户使用</h3><p>（1）命令接口：提供一组命令供用户间接/直接操作；<br>（2）程序调用：一组系统调用命令组成，是操作系统提供给编程人员唯一接口，调用命令供用户程序使用；（用户编程需要打印输出，提供指令：write()）<br>（3）图像界面接口：图标、菜单、窗口，形成一个直观易懂，使用方便的计算机操作环境，终端窗口采用命令行。  </p><h3 id="7-设备分配算法中，数据结构主要包含四个表分配顺序是"><a href="#7-设备分配算法中，数据结构主要包含四个表分配顺序是" class="headerlink" title="7.设备分配算法中，数据结构主要包含四个表分配顺序是"></a>7.设备分配算法中，数据结构主要包含四个表分配顺序是</h3><p>系统设备表（SDT）、设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）。</p><h3 id="8-程序状态字（PSW，专门的寄存器指示处理器状态）"><a href="#8-程序状态字（PSW，专门的寄存器指示处理器状态）" class="headerlink" title="8.程序状态字（PSW，专门的寄存器指示处理器状态）"></a>8.程序状态字（PSW，专门的寄存器指示处理器状态）</h3><p>（1）包含：CPU工作状态码（指明管/目态）；条件码（指令结果）；终端屏蔽码（是否允许中断）；<br>（2）状态标志：CF（有进位）、ZF（为零）、SF（符号）、OF（溢出）、TF（陷阱）、IF（中断屏蔽）、VIF（虚拟中断）、VIP（虚拟自断待决）、IOPL（IO特权级别）  </p><h2 id="二、操作系统运行机制"><a href="#二、操作系统运行机制" class="headerlink" title="二、操作系统运行机制"></a><center>二、操作系统运行机制</center></h2><h3 id="1-CPU中的存储器"><a href="#1-CPU中的存储器" class="headerlink" title="1.CPU中的存储器"></a>1.CPU中的存储器</h3><p>（1）用户可见寄存器：主要用于各种算术逻辑指令和访问指令（数据寄存器、地址寄存器、条件码寄存器）<br>（2）控制和状态寄存器：用于控制处理器的操作（程序计数器PC、指令寄存器IR、程序状态寄存器PSW）  </p><h3 id="2-中断与异常的分类"><a href="#2-中断与异常的分类" class="headerlink" title="2.中断与异常的分类"></a>2.中断与异常的分类</h3><p>（1）中断：（外部事件引起的）时钟中断；输入输出中断（键盘输入）；控制台中断；硬件故障中断；网卡上数据区满（数据传输完成）；（堆栈溢出）；（被0除）<br>（2）异常：（内部事件引起的）程序性中断（执行指令产生的结果）；访管指令中断（被清零）；</p><h3 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h3><p>（1）概念：运行在用户态（CPU在用户程序中执行）被调用程序在系统态（CPU在系统程序中执行）；系统调用可嵌套使用，即一个被调用过程执行期间还可以调用另一个，一般可多次调用但不能无限制调用；<br>（2）分类：进程控制类（创建/终止进程）、文件操作（打开）、进程通信类、设备管理类（请求/释放设备）、信息维护类（时间日期）；<br>（3）参数传递：由陷入指令自带参数（只能携带几个）；通过寄存器传递参数（内存开辟专门的堆栈传递参数）；<br>（4）一般调用在，被调用过程执行结束后，会直接返回调用程序；系统调用在结束调用，首先会对所要求的进程进行优先级分析，若调用进程不具备高优先级则会产生重新调度；  </p><h2 id="三、进程线程模型"><a href="#三、进程线程模型" class="headerlink" title="三、进程线程模型"></a><center>三、进程线程模型</center></h2><h3 id="1-多道程序环境特点"><a href="#1-多道程序环境特点" class="headerlink" title="1.多道程序环境特点"></a>1.多道程序环境特点</h3><p>独立性；随机性（输入输出都是随机的）；资源共享（导致执行速度制约）。</p><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h3><p>（1）概念：计算机程序（指令、数据组成）关于数据集合上的一次运行活动，是资源分配的基本单位；<br>（2）特点：并行性；独立性（独立资源分配单元）；异步性（不可预知速度的向前推行）；动态性；交往性。<br>（3）组成：PCB、指令和数据三部分组成；<br>（4）进程控制块（PCB）<br>A.组成：进程名、进程号、存储信息、进程标识符、进程优先级、进程当前状态、资源清单、消息队列指针、进程队列指针、打开当前文件等调度信息和PSW、时钟、界地址寄存器等现场信息；<br>B.组织方式：线性方式、索引方式、链接方式、队列方式（就绪队列、等待队列、运行队列）；<br>C.特征：是进程的灵魂；必须常驻内存；PCB的运行状态只可以通过操作系统读取。<br>（5）进程控制：通过原语实现对进程在整个生命周期中各种状态间的转换；用于进程控制的原语一般有创建进程、撤销进程、挂起进程、激活进程、阻塞进程、唤醒进程以及改变进程优先级等。<br>（6）创建进程：<br>A.步骤：申请空白PCB；为新进程分配资源；初始化PCB；将新进程插入就绪队列末尾。<br>B.创建进程的时机：用户登录；系统初始化；用户系统调用；初始化批处理作业。  </p><h3 id="3-进程状态及转换"><a href="#3-进程状态及转换" class="headerlink" title="3.进程状态及转换"></a>3.进程状态及转换</h3><p>（1）三状态模型：运行状态、就绪状态、等待状态（阻塞状态）。<br>其中运行状态转换到就绪状态有3种可能性：时间片用完；进程创建完成；被调度程序强占CPU（对于非强制式是：“一个进程运行结束”）；<br>运行状态转换阻塞状态：请求系统服务、启动某种操作、新数据尚未到达、无新工作可做。<br>（2）五状态模型：运行、就绪、阻塞、创建、结束。<br>Linux上进程有五种状态：运行、中断、不可中断、僵尸状态、停止状态。<br>（3）七状态模型；运行、就绪、阻塞、创建、结束、激活（外-&gt;内）、挂起（内-&gt;外）。 </p><h3 id="4-线程"><a href="#4-线程" class="headerlink" title="4.线程"></a>4.线程</h3><p>（1）概念：进程中的实体，不能独立于进程存在；是CPU调度和分派的基本单位；不同的线程可以执行相同的程序；同一进程中各线程共享内存空间；自己不拥有系统资源，只拥有一点运行中必不可少的资源；每个线程有一个标识符和一张线程描述表，记录了线程执行的寄存器和用户栈等现场；<br>（2）特点：花费开销少、切换花费时间少、内部通信快、能独立工作；<br>（3）线程操作含义：  </p><table><thead><tr><th align="left"><code>pthread_join</code>：等待一个特定的线程退出；</th><th align="left"><code>pthread_yield</code>：线程让出CPU（主动释放）；</th></tr></thead><tbody><tr><td align="left"><code>pthread_creat</code>：创建线程库函数；</td><td align="left"><code>pthread_exit</code>：结束一个线程的库函数</td></tr></tbody></table><h3 id="5-CPU调度分类"><a href="#5-CPU调度分类" class="headerlink" title="5.CPU调度分类"></a>5.CPU调度分类</h3><p>高级调度（创建进程）、中级调度（调入内存）、低级调度（分配CPU）。</p><h3 id="6-调度"><a href="#6-调度" class="headerlink" title="6.调度"></a>6.调度</h3><p>（1）功能：记录系统中所有进程执行状态；从就绪队列中选出一个CPU分配给它；选中PCB有关现场信息（PSW、通用寄存器等）送往CPU的寄存器中，让他占用执行。<br>（2）时机：CPU资源让出来不一定调度，CPU资源占用一定不调度；可强占方式（当优先级高的进程运行存在时，立即进行调度，转让CPU资源）与不可强占方式（进程执行完毕才释放CPU）。<br>（3）调度算法：先来先服务FCFS（不可强占）；最短时间作业算法SJF；轮转法RR；最高响应比优先算法HRRF（介于FCFS与SJF之间的折中算法，即考虑等待时间又不使长作业等待时间过长）；多级反馈队列。操作系统不能在运行中动态改变进程调度算法。</p><h2 id="四、存储管理方案"><a href="#四、存储管理方案" class="headerlink" title="四、存储管理方案"></a><center>四、存储管理方案</center></h2><h3 id="1-进程互斥的解决办法"><a href="#1-进程互斥的解决办法" class="headerlink" title="1.进程互斥的解决办法"></a>1.进程互斥的解决办法</h3><p>竞争各方平等协商；引入进程管理者</p><h3 id="2-计算机中资源共享的程序可分为三个层次"><a href="#2-计算机中资源共享的程序可分为三个层次" class="headerlink" title="2.计算机中资源共享的程序可分为三个层次"></a>2.计算机中资源共享的程序可分为三个层次</h3><p>（1）互斥；利用硬件解决的互斥方法简单、支持多个临界区、适用范围广；不能实现“让权等待”；<br>（2）死锁：<br>（3）饥饿：  </p><h3 id="3-临界资源分成四个部分"><a href="#3-临界资源分成四个部分" class="headerlink" title="3.临界资源分成四个部分"></a>3.临界资源分成四个部分</h3><p>（1）进入区：（P原语）；<code>while TS(&amp;lock)</code><br>（2）临界区：访问临界资源的一段代码；<code>n=fetch(balance)</code><br>（3）退出区：（V原语）<code>lock=FLASE</code><br>（4）剩余区：代码其余的部分<code>output(list)</code>  </p><h3 id="4-进程同步机制应遵循的准则"><a href="#4-进程同步机制应遵循的准则" class="headerlink" title="4.进程同步机制应遵循的准则"></a>4.进程同步机制应遵循的准则</h3><p>空闲则入、忙则等待、有限等待、让权等待。</p><h3 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h3><p>（1）只能通过初始化和两个标准的原语来访问；<br>（2）初始化可指定一个非负整数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数；<code>P(empty)</code> <code>V(full)</code><br>（3）同步：信息量empty，初始值K；信号量full，初始值0<br>    互斥：信号量mutex，初始值为1.（占用为1空闲为0）<br>（4）系统直接通信时，发送原语：<code>send(receiver,message)</code>  </p><h3 id="6-管程"><a href="#6-管程" class="headerlink" title="6.管程"></a>6.管程</h3><p>（1）定义了一个数据结构和能为并发进程所执行的一组操作。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外什么的过程中直接访问管程数据结构；管程能保障共享资源互斥执行；是一种同步机制；将共享变量及对共享变量的操作封装在一起<br>（2）任一时刻中，管程中只有一个活跃进程；所有临界区转换成管程，则只许一个进程使用临界区内代码。管程本身无法保证互斥；<br>（3）管程对象：共享的数据结构和一组操作过程。<br>（4）为解决进程同步关系，引入条件变量，在条件变量上实施P、V操作；  </p><h3 id="7-进程间的通信"><a href="#7-进程间的通信" class="headerlink" title="7.进程间的通信"></a>7.进程间的通信</h3><p>（1）共享内存：用于多个进程并发执行且相互通信，适合传输大量信息；设置一个公共内存区，一组向其中写，一组从公共内存读；不需要在系统中产生多份相同的拷贝。<br>（2）消息机制：利用内存中若干缓存区组织成队列，依赖进程或基础框架来调用实际执行的代码；缓冲区中包括：消息缓冲区、消息指针、互斥信息量、同步信息量、发送和接收原语。<br>（3）管道通信：通过两个进程，打开一个共享文件，实现进程间的通信；字符流形式联系，不足是通信速度较慢。<br>（4）信箱通信：发送进程首先创建一个链接两个进程的通信机制，然后把向信息送入该机制；发送进程和接受进程不直接联系，接收进程可以在任何时刻从该机制中取出信息。  </p><h3 id="8-PV操作"><a href="#8-PV操作" class="headerlink" title="8.PV操作"></a>8.PV操作</h3><p>PV操作可以实现两个进程互斥、进程同步和进程前趋关系；<br>PV同步机制缺点：可读性差、不利于修改和维护、正确性差；P操作一次减一，V操作一次加一。  </p><h3 id="9-可以实现进程互斥的算法"><a href="#9-可以实现进程互斥的算法" class="headerlink" title="9.可以实现进程互斥的算法"></a>9.可以实现进程互斥的算法</h3><p>Peterson算法、TS指令、Swap或Exchange命令、信号量；</p><h3 id="10-进程之间的关系有"><a href="#10-进程之间的关系有" class="headerlink" title="10.进程之间的关系有"></a>10.进程之间的关系有</h3><table><thead><tr><th align="left">相互感知</th><th align="left">交互关系</th><th align="left">一个进程对其他进程的影响</th><th align="left">潜在控制问题</th></tr></thead><tbody><tr><td align="left">相互不感知</td><td align="left">竞争</td><td align="left">两进程的结果无影响</td><td align="left">互斥、死锁、饥饿</td></tr><tr><td align="left">直接感知</td><td align="left">通信协作</td><td align="left">一个进程依赖其他进程</td><td align="left">死锁、饥饿</td></tr><tr><td align="left">间接感知</td><td align="left">共享协作</td><td align="left">一个进程依赖其他进程</td><td align="left">互斥、死锁、饥饿</td></tr></tbody></table><h3 id="11-地址重定位"><a href="#11-地址重定位" class="headerlink" title="11.地址重定位"></a>11.地址重定位</h3><p>将逻辑地址转换成绝对地址；动态重定位（每条指令执行时；需要软件硬件相互配合实现，其中硬件包括基址寄存器和一个地址转换线路组成）和静态重定位（程序执行前已转换好地址）。  </p><h3 id="12-内存管理"><a href="#12-内存管理" class="headerlink" title="12.内存管理"></a>12.内存管理</h3><p>（1）单一用户管理：一个时间内，一个用户进程独占内存；<br>（2）分区管理：固定分区；可变分区（空闲分区策略：最先适应算法、最优适应算法、最坏适应算法、下次适应算法）；可以满足多道程序设计且设计上最简单；内存使用不充分、较为严重碎片、不能提供虚拟内存、受物理内存不足限制。<br>利用移动技术，可以实现碎片整合；利用交换技术，在磁盘上保存内存放不下的进程（代码、PCB和数据），需要时再装入内存中，是由操作系统控制。<br>（3）页式管理：把一个逻辑地址连续分散存放到几个不连续的内存区域。不要求作业或进程的程序段和数据在内存中连续存放，从而有效解决“碎片”多的问题；动态页式管理提供了内存和外存统一管理的虚存实现方式，提高了存储空间利用率；页面大小可以改变但用户不可以动态改变页面大小。通常管理空闲物理内存的方法有：空闲块链表法、位示图、空闲页面表。<br>A.空闲块的分配和回收：采用主存分配表、位示图和页表方式；页表中，存储块号与页号一一对应，一级页表共需访问内存2次完成数据提取；二级页表每执行一条指令至少需要访问3次内存；<br>B.快表（TLB）存放在高速缓存（介于主存和CPU之间的存储器，高速缓存器与内存之间信息调度和传送是通过硬件完成的）中；页式虚拟存储管理，部分页在内存中，其余在外存中（磁盘文件区），需要用到：请求调用页和预调页策略。<br>C.置换策略有：固定分配局部置换、可变分配全局置换、可变分配局部置换；（固定/可变指：块数是否可变；局部/全局：指作业以内或外）<br>D.页面置换算法：<br>FIFO：会出现Belady现象，随着分配给进程的物理页面增加，缺页率增加；<br>LRU：最近最久未使用算法，需要记录访问位；<br>LFU：最近最不经常使用算法，当前时间访问次数最少，需要访问计数器；<br>NRU：最近未使用页面置换算法，需要记录访问位；<br>CLOCK：时钟算法，需要记录访问位；<br>理想页面置换算法<br>（4）段氏管理：存储以段划分；<br>（5）段页式管理：先分段、再分页、每页对应块、可连续可不连续存储。<br>其中，页式、段氏式和段页式管理可以与虚拟存储技术结合使用。  </p><h3 id="13-链接"><a href="#13-链接" class="headerlink" title="13.链接"></a>13.链接</h3><p>提高检索速度、节省存储空间的软链接，把所有编译后得到的目标模块连接装配起来，再与函数库想连接成一个整体的过程。</p><h3 id="14-虚拟页面存储管理"><a href="#14-虚拟页面存储管理" class="headerlink" title="14.虚拟页面存储管理"></a>14.虚拟页面存储管理</h3><p>（1）存在问题：页面抖动、Belady现象、缺页中断、页面写错误。<br>（2）解决办法：采用工作集算法可以缓解页面抖动（操作系统为每一个进程保持一个工作集，工作集随时间而变化，每个进程提供与工作集大小相等的物理界面）<br>（3）需要的硬件支持：足够大内外存；虚拟地址到物理地址映射机制；缺页中断处理机制。  </p><h3 id="15-碎片"><a href="#15-碎片" class="headerlink" title="15.碎片"></a>15.碎片</h3><p>（1）内碎片：分配出内存，没有得到利用。固定分区、页式、段页式<br>（2）外碎片：内存空间无法满足分配要求。可变分区、虚拟段式。<br>16.进程中断，选中一个页面进行淘汰时，只需将页面移除，修改页面有效位，其余标志位不变；<br>当创建一个新进程，装入一个页面，对应页表项中的：内存号、驻留位、访问位需要修改；<br>当页面被修改时，需要修改的位：访问位、修改位；<br>将页面调入内存，需要修改位：内存号、驻留位、访问位。  </p><h3 id="17-虚拟存储器"><a href="#17-虚拟存储器" class="headerlink" title="17.虚拟存储器"></a>17.虚拟存储器</h3><p>（1）在虚拟存储系统中，进程的部分程序装入后便可运行；<br>（2）虚拟存储技术允许用户使用比物理内存更大的存储空间；<br>（3）虚拟内存必须有硬件支持。  </p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>程序的局部性分空间局部性和时间局部性，空间局部性是指一旦程序访问了某个存储单元，其附近的存储单元也将被访问，程序代码执行具有顺序性。时间局部性指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。  </p><h2 id="五、文件系统设计与实现技术"><a href="#五、文件系统设计与实现技术" class="headerlink" title="五、文件系统设计与实现技术"></a><center>五、文件系统设计与实现技术</center></h2><h3 id="1-文件分类"><a href="#1-文件分类" class="headerlink" title="1.文件分类"></a>1.文件分类</h3><p>（1）按用途分：系统文件、用户文件、库函数文件；<br>（2）按组织形式：普通文件、目录文件、特殊文件（Unix中I/O设备被视为特殊文件）；<br>（3）保护方式：只读文件、读写文件、可执行文件、无保护文件；<br>（4）存放实限分类：临时文件、永久文件、档案文件；<br>（5）组织结构：逻辑文件（用户可见；无结构的字符流式文件、定长记录文件和不定长记录文件构成的记录树）、物理文件（存放在磁盘上：顺序文件、链式文件、索引文件）  </p><h3 id="2-文件物理结构"><a href="#2-文件物理结构" class="headerlink" title="2.文件物理结构"></a>2.文件物理结构</h3><p>即文件存储的结构；顺序结构、链接结构、索引结构； </p><table><thead><tr><th align="left">存储介质</th><th align="left">磁带</th><th align="left">磁盘</th></tr></thead><tbody><tr><td align="left">物理结构</td><td align="left">连续结构</td><td align="left">连续    链接    索引（多级索引）</td></tr><tr><td align="left">存取结构</td><td align="left">顺序</td><td align="left">顺序    顺序    顺序</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">随机 &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp随机</td></tr></tbody></table><h3 id="3-磁盘"><a href="#3-磁盘" class="headerlink" title="3.磁盘"></a>3.磁盘</h3><p>（1）寻访时间：寻道时间（最长）、延迟时间、传输时间（最短）；<br>（2）磁盘调度：FCFS、SSTF（最短寻道时间，容易引起饥饿现象）、SCAN（电梯算法，来回服务）、C-SCAN（循环扫描，单向）  </p><h3 id="4-文件目录"><a href="#4-文件目录" class="headerlink" title="4.文件目录"></a>4.文件目录</h3><p>实现按名存取，包含文件名和文件的起始地址，用以建立文件名（&lt;255字符）与存储地址的对应关系；必须信息：FCB、文件结构信息和文件管理信息。<br>（1）FCB包含：文件名、文件号、用户名、文件物理地址、文件长度、口令、修改/访问/建立时间；<br>（2）管理形式分：一级目录、二级目录、树型目录（搜索快；层次清楚；解决不用用户文件重命名问题；用户不可以创建根目录）<br>（3）路径名搜索：全路径名和相对路径（加快搜索速度）；  </p><h3 id="5-存储空间的分配与回收（文件存储空间的管理方法）"><a href="#5-存储空间的分配与回收（文件存储空间的管理方法）" class="headerlink" title="5.存储空间的分配与回收（文件存储空间的管理方法）"></a>5.存储空间的分配与回收（文件存储空间的管理方法）</h3><p>位示图、空闲块表、空闲链表、成组链接表（UNIX）。</p><h3 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6.文件系统"></a>6.文件系统</h3><p>（1）优化：块高速缓存；合理分配磁盘时间；磁盘驱动调度；目录项分解；<br>（2）FAT：是文件分配表；链接结构；FAT16表示16位簇号，支持8个字符文件名；<br>（3）安全：建立副本、定时转存、规定文件的存取权限。<br>（4）文件存储空间：分配单位数据块；<br>（5）从用户角度：建立文件系统的目标是实现“按名存取”；<br> &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp从系统角度：看文件系统主要关注文件存储位置；  </p><h3 id="7-打开文件时，系统要完成的"><a href="#7-打开文件时，系统要完成的" class="headerlink" title="7.打开文件时，系统要完成的"></a>7.打开文件时，系统要完成的</h3><p>（1）根据文件名查找目录，找到FCB；（打开文件第一步，继续<code>open()</code>操作，将FCB写入内存）<br>（2）根据打开方式，共享说明和用户身份检查，访问合格性；<br>（3）根据文件号，打开文件表，看文件是否被打开；<br>（4）在用户打开文件中取一空表项，填写打开方式等，并指向系统打开文件表对应的表项；  </p><h3 id="8-物理结构"><a href="#8-物理结构" class="headerlink" title="8.物理结构"></a>8.物理结构</h3><p>是文件的逻辑块到磁盘号的转换；</p><h3 id="9-外存储存取过程"><a href="#9-外存储存取过程" class="headerlink" title="9.外存储存取过程"></a>9.外存储存取过程</h3><p>读状态–&gt;置数据-&gt;置地址-&gt;置控制-&gt;读状态</p><h3 id="10-创建文件操作过程"><a href="#10-创建文件操作过程" class="headerlink" title="10.创建文件操作过程"></a>10.创建文件操作过程</h3><p>检查文件名是否合法；同目录下是否重名；目录中是否有空闲位置；填写目录项内容（文件名、用户名、存取权限、长度置零、首地址）；</p><h3 id="11-文件描述符"><a href="#11-文件描述符" class="headerlink" title="11.文件描述符"></a>11.文件描述符</h3><p>内核利用文件描述符来访问文件。文件描述符是非负整数，打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符来指定待读写的文件。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h3 id="2-对文件的操作"><a href="#2-对文件的操作" class="headerlink" title="2.对文件的操作"></a>2.对文件的操作</h3><p>（1）关闭文件操作：系统根据用户提供的文件名/文件标识符查找FCB；在该FCB的相关内容做修改；置FCB为“非活跃”；写回磁盘。<br>（2）删除文件操作：查找文件；检查删除合法性；收回FCB资源；收回文件存储空间。<br>（3）访问文件：首次访问时通常访问文件路径名，之后对文件访问通常使用文件描述符。  </p><h2 id="六、I-O设备管理"><a href="#六、I-O设备管理" class="headerlink" title="六、I/O设备管理"></a><center>六、I/O设备管理</center></h2><h3 id="1-设备分类"><a href="#1-设备分类" class="headerlink" title="1.设备分类"></a>1.设备分类</h3><p>（1）按共享属性：独占设备、共享设备（磁盘）、虚拟设备；<br>（2）按信息组织方式分类：块设备（磁盘/磁带，一般512B-4KB）；字符设备（键盘、显示器、打印机）；  </p><h3 id="2-I-O硬件"><a href="#2-I-O硬件" class="headerlink" title="2.I/O硬件"></a>2.I/O硬件</h3><p>CPU和主存（中央部分）；接口；外围设备控制器（内有寄存器）；外围设备  </p><h3 id="3-I-O设备数据传输控制方式"><a href="#3-I-O设备数据传输控制方式" class="headerlink" title="3.I/O设备数据传输控制方式"></a>3.I/O设备数据传输控制方式</h3><p>（1）程序直接控制方式：“忙-等待”<br>（2）中断控制方式：实现了主机和外围设备的并行工作；CPU是不是会跑去看数据是否可以输入输出；适用于键盘以字符为单位读取方式；关键硬件中断控制器、地址总线和数据总线、设备控制器；<br>（3）DMA：对输入/输出设备由DMA完成，在DMA控制器的作用下，设备和主存之间可以批量进行数据交换，而不用CPU干预；“窃取”总线控制权；适用于对块设备的存取；DMA控制器、地址总线和数据总线；<br>（4）通道控制方式：工作在内存中；实现外围设备的统一管理和外围设备与内存之间的数据传输；所需CPU干预更少；可以实现CPU、通道和输入输出设备三者之间的并行操作；适用于现代计算机内的大量数据交换；主要限于与I/O操作有关的指令和程序；通道控制器、地址总线、数据总线、设备控制器和通道程序代码；分数据选择通道、字节多路通道和数组多路通道。  </p><h3 id="4-I-O软件分层"><a href="#4-I-O软件分层" class="headerlink" title="4.I/O软件分层"></a>4.I/O软件分层</h3><p>中断处理程序（设备硬件）；设备驱动程序；与设备无关的系统软件（设备独立层）；用户控件的I/O软件（用户层）  </p><h3 id="5-设备无关层实现功能（提供一致的系统调用）"><a href="#5-设备无关层实现功能（提供一致的系统调用）" class="headerlink" title="5.设备无关层实现功能（提供一致的系统调用）"></a>5.设备无关层实现功能（提供一致的系统调用）</h3><p>（1）统一命名：实现逻辑设备命名与物理设备的转换；<br>（2）设备保护；<br>（3）缓冲：对不同速度的设备使用缓冲区来匹配；<br>（4）提供与设备无关的逻辑块；<br>（5）独占设备的分配和释放；<br>（6）出错处理：向用户报告出错处理情况；<br>（7）存储设备的块分配。  </p><h3 id="6-I-O设备管理"><a href="#6-I-O设备管理" class="headerlink" title="6.I/O设备管理"></a>6.I/O设备管理</h3><p>（1）设备表：建立逻辑设备与物理设备之间的对应关系；<br>（2）设备管理任务：缓冲区管理、设备分配（需要考虑：设备固有属性；设备分配算法；设备分配安全性；设备独立性）、设备处理、虚拟设备以及实现设备独立。<br>（3）引入技术：缓冲技术、设备分配技术、SPLOOING技术、DMA技术、通道技术。<br>（4）缓冲池管理：实现进程访问缓冲区同步。  </p><h3 id="7-SPOOLING组成"><a href="#7-SPOOLING组成" class="headerlink" title="7.SPOOLING组成"></a>7.SPOOLING组成</h3><p>输入井和输出井、输入进程和输出进程、输入缓冲区和输出缓存区。  </p><h2 id="七、死锁"><a href="#七、死锁" class="headerlink" title="七、死锁"></a><center>七、死锁</center></h2><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1.死锁"></a>1.死锁</h3><p>在对资源的管理、分配和使用不当，会产生死锁现象；<br>（1）产生原因：竞争资源；进程推进顺序不合理。（没有“调度不合理”的原因）<br>（2）产生必要条件：互斥条件（资源互斥使用）；不可剥夺条件（已分配资源不可剥夺）；请求和保持条件（申请占有一部分资源，继续占用已分配的资源，部分分配资源）；循环等待条件（前一个进程拥有后一个进程所请求的资源，资源申请形成环路）；<br>（3）进入阻塞状态，无法被唤醒。  </p><h3 id="2-饥饿"><a href="#2-饥饿" class="headerlink" title="2.饥饿"></a>2.饥饿</h3><p>当等待时间进程推迟和响应带来明显影响时；  </p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="3.活锁"></a>3.活锁</h3><p>“忙等待式”，没有阻塞，可被调动，但无进展（不主动放弃CPU）；<br>饥饿：“阻塞状态”，没有阻塞，但被无限推后，（主动放弃CPU）；  </p><h3 id="4-解决死锁方法"><a href="#4-解决死锁方法" class="headerlink" title="4.解决死锁方法"></a>4.解决死锁方法</h3><p>（1）预防死锁：“资源有序分配法”；SPOOLing系统的建立；一次分配所有资源；剥夺其他进程的资源。（静态分配，分配时加锁）<br>（2）避免死锁：银行家算法；<br>（3）死锁检测：定时运行资源分析程序；<br>（4）剥夺资源法、撤销进程法和重启。  </p><h3 id="5-几种死锁类型"><a href="#5-几种死锁类型" class="headerlink" title="5.几种死锁类型"></a>5.几种死锁类型</h3><p>（1）同类资源死锁：“P1申请一页内存，P2申请一页资源…….”；<br>（2）不同类资源死锁：“P1拥有设备A请求设备B，P2拥有设备B请求A”；<br>（3）PV操作互斥死锁：“P1、P2先进行同步信号量P操作，再进行互斥信号量P操作”；<br>（4）临时资源死锁：“P1等待P2发来信件Q后向P2发送信件R，P2等待P1发来信件R后向P1发送信件Q”。  </p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><center>计算机网络</center></h1><h2 id="一、网络技术基础"><a href="#一、网络技术基础" class="headerlink" title="一、网络技术基础"></a><center>一、网络技术基础</center></h2><h3 id="1-网络分类"><a href="#1-网络分类" class="headerlink" title="1.网络分类"></a>1.网络分类</h3><p>（1）宽带城域网（MAN）：双环光纤传输；FDDI；（2）无线局域网（WLAN）；（3）无线自组网（Ad hoc）（自组织；对等；无线网络）；（4）无线传感网（WSN）：Ad hoc与传感器技术结合；（5）无线网状网（WMN）：用于扩大范围；对Wimax和WLAN的补充  </p><h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h3><p>（1）Unix操作系统：小型机、C语言（第一版本由汇编语言编译）、部分开源；集中式、多用户，多任务，分时操作系统；贝尔公司开发；<br>IBM—AIX  SUN公司—Solaris  HP—HP-UN<br>（2）Linux操作系统：继承了Unix以网络为核心的设计，核心部分：内核；开源操作系统；版本很多；由不同组织管理维护；不是Unix操作系统的变种。<br>Red Hat<br>（3）Windows NT是微软公司开发的闭源系统；采用32位操作系统，可以提供全面的网络服务功能；基于不对等结构，分Windows NT Sever和Windows NT Workstation。  </p><h3 id="3-拓扑结构"><a href="#3-拓扑结构" class="headerlink" title="3.拓扑结构"></a>3.拓扑结构</h3><p>（1）环型拓扑：传输延时确定；<br>（2）网状拓扑：广域网普遍使用；  </p><h3 id="4-数据报方式和虚拟电路方式"><a href="#4-数据报方式和虚拟电路方式" class="headerlink" title="4.数据报方式和虚拟电路方式"></a>4.数据报方式和虚拟电路方式</h3><p>（1）数据报方式（分组存储转发）：同一报文不同分组可以通过不同的传输路径；不同分组可能会出现乱序、重复和丢弃现象；分组均携带源地址和目的地址；延迟大，不适宜报文会话式；<br>（2）虚电路方式：传输之前在源节点和目的节点之间建立逻辑连接；每个结点可以与任意结点建立多条虚电路连接，不需要路由选择；一次通信所有分组通过虚电路顺序传输，分组不需要携带目的地址和源地址等信息；结点只进行纠错。  </p><h3 id="5-网络体系结构"><a href="#5-网络体系结构" class="headerlink" title="5.网络体系结构"></a>5.网络体系结构</h3><p>（1）ISO建立的OSI（开放系统互联）模型：<br>A.物理层（透明传输比特流）、数据链路层（MAC&amp;LLC）、网络层（选择路由IPSec）、传输层（端到端服务）、会话层、表示层（加密/解密）、应用层（提供应用进程交换和远程操作）；<br>（2）TCP/IP模型：IETF制定的<br>A.主机-网络层、互联层（IP/ARP/ICMP）、传输层（TCP\UDP）、<br>应用层（FTP\HTTP\RIP\NFS\SMTP\Telnet\SNMP\CIMP\PGP\S/MIME\）<br>B.开放式网络协议标准；与网络硬件无关；每一层服务上一层  </p><h3 id="6-计算机网络"><a href="#6-计算机网络" class="headerlink" title="6.计算机网络"></a>6.计算机网络</h3><p>以能够相互共享资源方式互联起来的自治计算机系统集合。 </p><h3 id="7-ARPANET"><a href="#7-ARPANET" class="headerlink" title="7.ARPANET"></a>7.ARPANET</h3><p>Internet的始祖，是世界范围内的广域网，是世界上开发的第一个运营的封包交换网络（分组交换网络技术），是美国国防部高级研究计划局研究的网络。</p><h2 id="二、局域网技术"><a href="#二、局域网技术" class="headerlink" title="二、局域网技术"></a><center>二、局域网技术</center></h2><h3 id="1-局域网三要素"><a href="#1-局域网三要素" class="headerlink" title="1.局域网三要素"></a>1.局域网三要素</h3><p>（1）网络拓扑：总线型、环型、星型；<br>（2）传输介质：双绞线、同轴电缆（最早）、光纤和无线信道；<br>（3）介质访问：按照介质访问控制方式分为共享介质和交换局域网。其中：<br>共享介质（总线型局域网：利用CSMA/CD避免冲突；环型局域网：利用令牌环控制冲突）  </p><h3 id="2-IEEE-802"><a href="#2-IEEE-802" class="headerlink" title="2.IEEE 802"></a>2.IEEE 802</h3><p>（1）对象：OSI的物理层和数据链路层。专门从事局域网的标准化工作。（不同局域网中，MAC和物理层可以不同，LLC（介质访问控制层）必须相同）<br>（2）分类：<br>802.3：定义CSMA/CD总线型介质访问MAC和物理层标准（以太网标准）；<br>802.4：定义令牌环网的协议标准；<br>802.11：无线局域网标准；<br>802.15：无线个人区域网介质访问MAC和物理层标准；<br>802.16：宽带无线局域网。  </p><h3 id="3-共享以太网"><a href="#3-共享以太网" class="headerlink" title="3.共享以太网"></a>3.共享以太网</h3><p>（1）概念：核心是集线器；ALOHA网络是基础；总线型局域网；核心技术：CSMA/CD；<br>（2）帧结构：<br>间导码7B 帧前定界符1B|目的地址6B源地址6B类型2B|数据46-1500B校验位4B（CRC）<br>（接收同步，不计帧头）    （帧头；类型：网络层协议）    （帧长64-1518B）<br>（3）以太网物理地址：长度48位，十六进制，两两一组，共6组；前三组生产公司，后三组生产商分配流水号，可分配地址2^47，第一位1则为组/广播；为0才可以分配给生产商。 </p><h3 id="4-高速局域网标准（MAC层与原标准兼容，仅定义物理层标准）"><a href="#4-高速局域网标准（MAC层与原标准兼容，仅定义物理层标准）" class="headerlink" title="4.高速局域网标准（MAC层与原标准兼容，仅定义物理层标准）"></a>4.高速局域网标准（MAC层与原标准兼容，仅定义物理层标准）</h3><p>（1）802.3u：Fast Ethernet，百兆以太网；<br>（2）802.3z：Gigabit Ethernet，千兆以太网，定义多模光纤或屏蔽双绞线；<br>802.3ab：Gigabit Ethernet，千兆以太网，定义单模光纤或非屏蔽双绞线；<br>采用GMII分隔物理层和MAC层；与传统以太网的帧格式一致；<br>（3）802.3ae:10Gigabit Ethernet，万兆以太网，使用光纤传输，只有全双工模式，不存在介质访问控制，传输距离不受冲突检测的限制。<br>（4）802.3ba：40/100Gigabit Ethernet（40Gbps网络使用波分复用技术，100GPS物理接口类型）</p><h3 id="5-交换式局域网"><a href="#5-交换式局域网" class="headerlink" title="5.交换式局域网"></a>5.交换式局域网</h3><p>（1）概念：典型的是交换式以太网，核心设备：以太网交换机（专用/共享端口）；可以在多个端口之间建立多个并发连接，实现多结点之间的并发连接，<br>（2）帧转发方式：直接交换；存储转发；改进直接交换（接收一帧前64B，检测由主机进行）；<br>（3）虚拟局域网（VLAN）组网方式：用交换机端口定义；MAC地址定义；基于网络层地址（IP）定义；基于广播组定义。  </p><h3 id="6-无线局域网"><a href="#6-无线局域网" class="headerlink" title="6.无线局域网"></a>6.无线局域网</h3><p>（1）按物理层传输方式分类：红外、直接序列扩频、跳频广播、微波；<br>（2）红外无线局域网IR、跳频扩频FSSS（将频带划分为多个信道，使用2.5GHZ的ISM频段）、直接序列扩频DSSS（所有接受结果使用相同频段通信）、窄带微波无线局域网。<br>（3）802.11定义的两种访问方式：无争用服务、争用服务；MAC层采用CSMA/CA避免冲突；支持AP访问模式和漫游访问模式；802.11管理帧为探测帧和认证帧；采用层次结构模型；MAC层主要功能是对无线环境的访问控制；物理层定义了红外、调频扩频与直接序列扩频的数据传输标准。<br>（4）802.11协议族：  </p><table><thead><tr><th align="left">802.11a:</th><th align="left">5HZ</th><th align="left">54M</th></tr></thead><tbody><tr><td align="left">802.11b:</td><td align="left">2.4HZ</td><td align="left">11M（跳频）</td></tr><tr><td align="left">802.11g:</td><td align="left">2.4HZ</td><td align="left">54M</td></tr><tr><td align="left">802.11n:</td><td align="left">5G</td><td align="left">100M</td></tr></tbody></table><p>（5）网络结构为：端站（有无线网卡的用户结点）、接入点（AP）、接入控制器（AC在WLAN与外部网络之间充当网关作用）、AAA服务器（计费、认证、授权；802.11认证有三种：基于IEEE 802.1x的认证、基于PPoE的认证和基于Web的认证）  </p><p>（6）1000BASE-SX:多模光纤<br>1000BASE-CX:屏蔽双绞线<br>1000BASE-LX:单模光纤<br>1000BASE-T:非屏蔽双绞线<br>100BASE-FX:单/多模光纤  </p><h3 id="7-不能够通信的原因"><a href="#7-不能够通信的原因" class="headerlink" title="7.不能够通信的原因"></a>7.不能够通信的原因</h3><p>不在一个虚拟子网中；不在一个子网中。</p><h3 id="8-总线局域网的特点"><a href="#8-总线局域网的特点" class="headerlink" title="8.总线局域网的特点"></a>8.总线局域网的特点</h3><p>所有结点都通过网卡连接到作为公共介质的总线上，通常采用双绞线或同轴电缆作为传输介质；所有的结点都可以发送或接收数据，但在一段时间内只允许一个结点通过总线发送数据（即半双工形式）；当一个结点通过总线以“广播”方式数据时，其他结点只能以“收听”方式接收数据；由于总线作为公共传输介质被多结点共享，因此会出现冲突现象。  </p><h2 id="三、Internet基础"><a href="#三、Internet基础" class="headerlink" title="三、Internet基础"></a><center>三、Internet基础</center></h2><h3 id="1-互联网构成"><a href="#1-互联网构成" class="headerlink" title="1.互联网构成"></a>1.互联网构成</h3><p>通信线路（基础设备）、路由器（主要设备，主要功能：维护路由表信息；转发IP数据报；选择最佳路径）、主机（信息资源和服务的载体）和信息资源。IP协议是Internet中的主要协议。  </p><h3 id="2-Internet的接入方式"><a href="#2-Internet的接入方式" class="headerlink" title="2.Internet的接入方式"></a>2.Internet的接入方式</h3><p>（1）电话线接入；<br>（2）ADSL接入：使用电话线路，完成非对称数据用户线路，ADSL调制解调器：具备网桥、路由器和调制解调的功能；<br>（3）HFC接入：有线电视网接入（混合光纤/同轴电缆），非对称数字用户线路；<br>（4）数据通信线路接入：（成本高）  </p><h3 id="3-IP协议"><a href="#3-IP协议" class="headerlink" title="3.IP协议"></a>3.IP协议</h3><p>（1）定义：IP数据报格式、对数据寻址和路由、数据报分片和重组、差错控制和处理等。<br>（2）IP服务特点：不可靠服务；面向无连接；尽最大努力投递；（一般不随意丢弃报文）<br>（3）IP网络特点：隐藏底层物理网络细节；不制定拓扑结构，不要求网络之间全部互联；在物理网络之间转发数据，信息可以跨网传输；公平对待互联网中每一个网络；使用同一的地址描述法。  </p><h3 id="4-IP地址（A-B-C-D-E类地址）"><a href="#4-IP地址（A-B-C-D-E类地址）" class="headerlink" title="4.IP地址（A\B\C\D\E类地址）"></a>4.IP地址（A\B\C\D\E类地址）</h3><p>（1）特殊IP地址：网络地址；广播地址（直接广播/有限广播：255.255.255.255）；回送地址（127.0.0.0）；本地地址（A:10.0.0.0/8;B:172.16.0.0/12;C:192.168.0.0/16）<br>（2）若要发送广播：源地址是本机，目的地址：网络号不变，主机号全为1.  </p><h3 id="5-地址解析协议ARP"><a href="#5-地址解析协议ARP" class="headerlink" title="5.地址解析协议ARP"></a>5.地址解析协议ARP</h3><p>（1）工作在互联层，能够实现IP到MAC的解析；<br>（2）工作原理：以广播形式发送请求报文（ARP请求），单播响应；<br>（3）通过高速缓存技术避免大量请求报文出现，提高有效性；拥有计时器的目的是保证主机ARP表的正确性。  </p><h3 id="6-IP数据报格式"><a href="#6-IP数据报格式" class="headerlink" title="6.IP数据报格式"></a>6.IP数据报格式</h3><p>（1）组成：报头区和数据区；<br>（2）数据报各字段及其功能：版本和协议类型；长度；服务类型；生存周期；头部校验和域（保证报头完整性，没有数据区校验字）；<br>（3）报头长度：32bit双字节为单位；总长度以8bit字节为单位。包含与分片和重组有关：标识（原数据是谁）、标志（是否是最后一片）和片偏移（顺序重组）</p><h3 id="7-IP封装、分片（MTU-最大传输单元，一帧携带最多能携带的数据量。）和重组。"><a href="#7-IP封装、分片（MTU-最大传输单元，一帧携带最多能携带的数据量。）和重组。" class="headerlink" title="7.IP封装、分片（MTU:最大传输单元，一帧携带最多能携带的数据量。）和重组。"></a>7.IP封装、分片（MTU:最大传输单元，一帧携带最多能携带的数据量。）和重组。</h3><h3 id="8-IP数据报选项"><a href="#8-IP数据报选项" class="headerlink" title="8.IP数据报选项"></a>8.IP数据报选项</h3><p>（1）目的：控制和测试；<br>（2）选项数据：<br>A.源路由：严格路由（严格按照路径转发）；松散路由（规定主要路由）；<br>B.记录路由：记录经过的所有路由IP；<br>C.时间戳  </p><h3 id="9-差错与控制"><a href="#9-差错与控制" class="headerlink" title="9.差错与控制"></a>9.差错与控制</h3><p>一个ICMP报文对应一个数据报<br>（1）ICMP差错控制报文：拥塞控制（源抑制报文）、路由控制（重定向报文）；<br>（2）请求/应答对：回应请求与应答（用于测试目的主机或路由器的可达性）、时间戳请求与应答（同步时间）、掩码请求与应答；<br>（3）ICMP特点：不享受优先权和不享受特别的可靠性；报告伴随丢弃；报文包含IP数据报头和数据前64比特数据。<br>（4）当路由器收到IP数据报，对IP数据报进行检测，当对其首部进行校验后发现数据报存在错误时，将抛弃该数据报。  </p><h3 id="10-路由器与选择"><a href="#10-路由器与选择" class="headerlink" title="10.路由器与选择"></a>10.路由器与选择</h3><p>（1）特殊路由：默认路由、待定主机路由（制定到达的主机）<br>（2）RIP协议（路由器信息协议）：采用V-D算法（距离-矢量算法），简单、中小型网络、多路径、动态IP互联网环境；距离按跳数计算；慢收敛（解决：限制路径最大距离；水平分割对策；保持策略；带触发刷新的毒性逆转对策）<br>（3）OSPF协议：采用L-S算法（链路-状态算法），大型网络、多路径、动态IP互联网环境；每个路由都有一个LSA，最终获得一个LSDB（链路状态数据图），收敛比V-D算法快。  </p><h3 id="11-IP组播技术"><a href="#11-IP组播技术" class="headerlink" title="11.IP组播技术"></a>11.IP组播技术</h3><p>（1）特点：使用组地址（D类地址）；动态组播地址，成员也是动态；不仅通过IP层，还与要底层硬件支持功能。<br>（2）相关协议：组播管理协议（IGMP,CGMP）、组播路由协议。<br>IGMP：Internet制定的，一方面主机通过本地路由器主动加入；一方面ICMP协议路由器会周期查询。组播路由由：源地址、组地址、入接口和出接口组成（前三个进行匹配）。  </p><h3 id="12-IPv6"><a href="#12-IPv6" class="headerlink" title="12.IPv6"></a>12.IPv6</h3><p>（1）地址：128位（IPv4:32位）；送回地址（0:0:0:0:0:0:0:1）；<br>（2）数据报格式：一个基本头（固定40B）、多个扩展头和一个高层协议数据单元组成。<br>（3）扩展头种类：逐跳选项报头；目的选项报头；路由报头（强制数据报经过指定路由）；分片头；</p><h3 id="13-TCP与UDP"><a href="#13-TCP与UDP" class="headerlink" title="13.TCP与UDP"></a>13.TCP与UDP</h3><p>（1）TCP:面向对象，可靠，全双工。（使用窗口机制进行流量控制；RTT算法进行数据丢失与重发；连接端口用12位二进制表示）<br>（2）UDP:非面向连接，不可靠，高效率。（应用程序提供可靠性保障）  </p><h3 id="14-NAT"><a href="#14-NAT" class="headerlink" title="14.NAT"></a>14.NAT</h3><p>内外网地址翻译。分类：静态NAT、动态NAT、网络地址端口转换NAPT（多个内网主机共享一个全局IP地址，同时访问外部网络）</p><h3 id="15-MTU"><a href="#15-MTU" class="headerlink" title="15.MTU"></a>15.MTU</h3><p>1500字节；一般IP首部为20字节，UDP首部为8字节，数据的净荷部分预留是1472字节；如果超出1472字节，就会出现分片现象。</p><h2 id="四、Internet基本服务"><a href="#四、Internet基本服务" class="headerlink" title="四、Internet基本服务"></a><center>四、Internet基本服务</center></h2><h3 id="1-应用进程响应并发请求分类"><a href="#1-应用进程响应并发请求分类" class="headerlink" title="1.应用进程响应并发请求分类"></a>1.应用进程响应并发请求分类</h3><p>（1）重复服务器：“先进先出”原则；<br>（2）并发服务器：每来一条请求，创建一个子进程。  </p><h3 id="2-对等计算机模型（P2P）基本结构"><a href="#2-对等计算机模型（P2P）基本结构" class="headerlink" title="2.对等计算机模型（P2P）基本结构"></a>2.对等计算机模型（P2P）基本结构</h3><p>（1）集中式（Napster，服务器通常只存储目录和索引信息）；（2）分布式非结构化（无中心节点；随机图；支持复杂查询；模糊查询；利用TTL机制控制泛洪；Gnutella）；（3）分布式结构化（无中心节点；采用分布式散列表DHT；支持精确关键字匹配查询；可扩展；维护复杂；pastry; tapestry; chord; CAN）；（4）混合式结构（索引结点维护搜索结点在搜索用户结点；skype; BT; pplive）  </p><h3 id="3-域名解析方式"><a href="#3-域名解析方式" class="headerlink" title="3.域名解析方式"></a>3.域名解析方式</h3><p>（1）分类：递归解析（一次完成）、反复解析（分层多次解析）；<br>（2）每一个域名服务器至少知道根服务器的IP地址及其父节点服务器的IP服务地址，才能解析。（本地域名服务器IP地址）<br>（3）提高域名解析的效率：解析从本地域名服务器开始；在域名服务器使用高速缓存技术；在主机上采用高速缓冲技术。  </p><h3 id="4-域名对象类型"><a href="#4-域名对象类型" class="headerlink" title="4.域名对象类型"></a>4.域名对象类型</h3><p>A—主机；MX—邮件交换；PTR—指针；CNAME—别名；SOA—授权开始；<br>HINFO—描述主机信息  </p><h3 id="5-远程登录中，网络虚拟终端利用NVT格式将不同的用户本地终端统一起来。"><a href="#5-远程登录中，网络虚拟终端利用NVT格式将不同的用户本地终端统一起来。" class="headerlink" title="5.远程登录中，网络虚拟终端利用NVT格式将不同的用户本地终端统一起来。"></a>5.远程登录中，网络虚拟终端利用NVT格式将不同的用户本地终端统一起来。</h3><h3 id="6-FTP服务"><a href="#6-FTP服务" class="headerlink" title="6.FTP服务"></a>6.FTP服务</h3><p>（1）C/S模型，利用TCP建立双向连接（一个控制连接/一个数据连接）；<br>（2）建立联系方式：主动模式（服务器主动，使用PORT命令将端口发送给服务器）；被动模式（服务器被动，向服务器发送PASV命令）<br>（3）FTP文件格式传输方式：文本文件传输（ASCII）；二进制文件传输（BINARY，不对文件格式进行任何变化，按照原始文件相同的位序以连续比特流方式进行传输）；<br>（4）FTP口令描述：delete—删除远程主机上的文件命令；pwd—显示远程主机的当前工作目录；  </p><h3 id="7-电子邮件系统"><a href="#7-电子邮件系统" class="headerlink" title="7.电子邮件系统"></a>7.电子邮件系统</h3><p>（1）SMTP：服务器之间的传递；主要目的是实现发送邮件的。<br>（2）POP3/IMAP：向邮件服务器进行读取（认证阶段、事务处理、更新阶段Quit）；<br>（3）电子邮件报文格式：RFC822、MIME.<br>（4）命令：PASS—用户邮件口令（认证）；STAT—查询报文总数和长度； REST—复位，删除标记，中止当前操作；NOOP—无操作（事务处理）  </p><h3 id="8-Web服务"><a href="#8-Web服务" class="headerlink" title="8.Web服务"></a>8.Web服务</h3><p>（1）HTML：页面规范，解释单元，能够对请求和返回进行页面翻译，显示内容；<br>（2）HTTP：客户机和服务器之间的传输协议，建立在TCP连接上，面向对象协议，精确定义了请求/相应报文；<br>（3）URL：页面地址，统一资源定位器；<br>（4）安全性：SSL协议（工作在传输层协议；位于TCP/IP协议与各类应用层协议之间）（浏览器安全性）（防止第三方偷看内容；防止第三方篡改）；CA证书（Web服务器）（证明自己）<br>（5）浏览器组成：控制单元（解释键盘/鼠标输入命令）、客户单元、解释单元组成。Web服务器不但需要保存大量的Web页面，而且需要接受和处理浏览器的请求，实现HTTP服务器功能。Web服务器不具备编辑Web页面的功能。</p><h3 id="9-安全性"><a href="#9-安全性" class="headerlink" title="9.安全性"></a>9.安全性</h3><p>（1）如何保护自己的计算机：浏览器将Internet世界划分成几个区域；<br>（2）如何验证站点真实性：利用Web站点传来的证书；<br>（3）如何避免他人假冒自己：用户可以在CA安全认证中心申请自己的证书，放在浏览器中；<br>（4）在与Web交互敏感信息时如何避免第三方篡改或偷看：使用安全套接层技术SSL技术；<br>（5）保证传输机密性：将Web站点放入可信站点区可保证信息传输的机密性；<br>（6）防止病毒传播：使用SSL技术。  </p><h3 id="9-网络蠕虫"><a href="#9-网络蠕虫" class="headerlink" title="9.网络蠕虫"></a>9.网络蠕虫</h3><p>独立、通过漏洞传播、早期利用电子邮件传播、自我复制和主动传播；木马是没有复制能力的。</p><h2 id="五、新型网络应用"><a href="#五、新型网络应用" class="headerlink" title="五、新型网络应用"></a><center>五、新型网络应用</center></h2><h3 id="1-即时通信（IM）"><a href="#1-即时通信（IM）" class="headerlink" title="1.即时通信（IM）"></a>1.即时通信（IM）</h3><p>（1）由IMPP工作组提出；IETF批准成为正式RFC文件；有RFC2778文件描述功能；该文件未提出即使通信系统必须使用同一标准。<br>（2）模式：客户机/服务器；客户机/客户机  </p><h3 id="2-QQ"><a href="#2-QQ" class="headerlink" title="2.QQ"></a>2.QQ</h3><p>（1）客户机的两种聊天方式：UDP主/TCP辅；服务器中转（无法直接通信）；<br>（2）采用自己私有的即时通信协议  ；<br>（3）每次登陆时客户机会获得一个来自服务器的会话密钥。  </p><h3 id="3-即时通信协议（基于SIP的SIMPLE；基于JABBER的XMPP）"><a href="#3-即时通信协议（基于SIP的SIMPLE；基于JABBER的XMPP）" class="headerlink" title="3.即时通信协议（基于SIP的SIMPLE；基于JABBER的XMPP）"></a>3.即时通信协议（基于SIP的SIMPLE；基于JABBER的XMPP）</h3><p>（1）SIP：工作在应用层；IEFT提出；可在TCP/UDP上传输；支持多种信息类型（文件、视频、图像）；用于创建、修改和释放一个或多个用户会话；分类（用户代理、代理服务器、重定服务器（用于规划SIP路径服务器，可与其他服务器共存一个设备中）、注册服务器）；SIP消息组成（起始行、消息头、一个标志消息头的空行、消息体）；SIP定义的6种请求消息（INVITE：邀请用户/服务器参加一个会话；ACK；OPTIONS:获取服务器相关能力；BYE:终止一次会话；CANCLE:取消挂起呼叫；REGISTER）；SIP消息通常可分为2类，从客户机到服务器的请求消息和从服务器到客户机的响应消息。<br>（2）SIMPLE：以SIP为基础，不需建立会话，支持多媒体会话；IEFT的SIMPEL工作组制定；IM消息以message命令为载体传输，每条IM由单独message命令传输，彼此独立。<br>（3）XMPP：工作在应用层;基于JABBER协议；由IEFT制定；由4个RFC文档组成；设计上延续E-mail系统；包含用户客户端、XMPP服务器、XMPP协议网管；XML是其核心，统一选址方案，实体地址叫做JID。<br>（4）基本服务：呈现服务和即时消息服务。  </p><h3 id="4-网络文件共享"><a href="#4-网络文件共享" class="headerlink" title="4.网络文件共享"></a>4.网络文件共享</h3><p>（1）NFS（网络文件系统）：Linux\Windows上均可使用；与主机操作系统无关；采用C/S结构；若想远程计算B的某一个文件系统：”mount:B:/usr/lib(远程主机目录)/usr/lib(本机目录)”<br>（2）NFS服务器共享出来的文件或目录都记录在/etc/exports文件中。  </p><h3 id="5-Windows-LAN文件共享"><a href="#5-Windows-LAN文件共享" class="headerlink" title="5.Windows LAN文件共享"></a>5.Windows LAN文件共享</h3><p>Windows2000以前的系统使用NetBIOS协议；以后使用CIFS协议</p><h3 id="6-P2P文件共享"><a href="#6-P2P文件共享" class="headerlink" title="6.P2P文件共享"></a>6.P2P文件共享</h3><p>（1）P2P:起源于Napster；BT（中心服务器tracker存放用户信息；种子文件：.torrent，包含存储用户信息和共享文件的信息）；源于MIT开源系统；加入DHT以实现无tracker服务器的文本传输；基于“六度分隔理论”、“世界最小理论假设”、“瓦斯特领导理论”。<br>（2）Maze：支持即时通信；参考Kerberos机制；在线资源搜索和文件目录视图；支持多点下载和断点续传；基于积点的资源交易体系；有种子机制；分布式认证机制（类似于信用卡机制）；类似URL表示文件位置；混合型P2P系统；包括集中式的用户管理服务器（注册、登录）、目录收集服务器、检索服务器、心跳服务器和种子服务器。<br>（3）P2P不支持种子机制；BT系统不支持积点机制；P2P可以实现用户之间直接传输；BT后期系统能够实现无Tracker服务器的文件传输；P2P与BT相互不兼容。  </p><h3 id="5-IPTV"><a href="#5-IPTV" class="headerlink" title="5.IPTV"></a>5.IPTV</h3><p>（1）业务种类：近式点播（NVOD，多个视频流依次间隔发送同样的内容）、真实点播电视（TVOD）和交互式点播（IVOD）;<br>（2）媒体内容分发（MCDN）技术组成：<br>A.内容发布：借助相关技术，将内容发布或投递到距离用户最近的远程服务点；<br>B.内容路由：网络负载均衡技术，重定向路由器以请求最近内容源响应；<br>C.内容交换：根据内容可用性、服务器可用性等，利用应用层交换技术，智能平衡负载流量；<br>D.性能管理：保证网络处于最佳状态，测量内容发布的端到端性能。  </p><h3 id="6-VOIP（基于IP网络的语音传输技术）"><a href="#6-VOIP（基于IP网络的语音传输技术）" class="headerlink" title="6.VOIP（基于IP网络的语音传输技术）"></a>6.VOIP（基于IP网络的语音传输技术）</h3><p>（1）组成：终端设备、网关（号码查询、建立通信、信号调制、压缩和解压缩、路由寻址）、多点控制单元（多终端）、网守（中央控制实体，负责用户注册和管理；消息控制中心；确定网关地址；计费管理；留存呼叫详细记录）<br>（2）Skype：利用VOIP和P2P技术；混合式网络结构；AES算法作为密钥，密钥长度256bit；加密保存好友列表；支持免费多方通信；采用iLBS和iSAC编码技术；系统中SN是动态生成的；可以进行NAT穿越。</p><h3 id="7-搜索引擎组成"><a href="#7-搜索引擎组成" class="headerlink" title="7.搜索引擎组成"></a>7.搜索引擎组成</h3><p>搜索器、检索器、索引器、用户接口。</p><h3 id="8-ICQ、AOL采用OSCAR通信协议。"><a href="#8-ICQ、AOL采用OSCAR通信协议。" class="headerlink" title="8.ICQ、AOL采用OSCAR通信协议。"></a>8.ICQ、AOL采用OSCAR通信协议。</h3><h3 id="9-网管模型"><a href="#9-网管模型" class="headerlink" title="9.网管模型"></a>9.网管模型</h3><p>（一般采用网络管理者-网管代理模型，管理者实际是运行在计算机操作系统上的一组应用程序，代理位于被管理的设备内部，一个管理者可以和多个代理之间进行信息交换）<br>（1）组织模型描述网管系统的组成部分；<br>（2）信息模型描述网管系统的对象命名；<br>（3）通信模型描述网管系统的管理协议；  </p><h2 id="六、网络管理与网络安全"><a href="#六、网络管理与网络安全" class="headerlink" title="六、网络管理与网络安全"></a><center>六、网络管理与网络安全</center></h2><h3 id="1-网络管理"><a href="#1-网络管理" class="headerlink" title="1.网络管理"></a>1.网络管理</h3><p>（1）管理对象：物理介质、计算机设备和网络互连设备（硬件资源）；操作系统、应用软件和通信软件（软件资源）；<br>（2）目标：用户及运营商对网络的有效性、可靠性、开放性、综合性、安全性和经济性。（3）模型：集中式管理和分布式管理（时效好）  </p><h3 id="2-网络管理功能"><a href="#2-网络管理功能" class="headerlink" title="2.网络管理功能"></a>2.网络管理功能</h3><p>（1）配置管理：包含两阶段：网络初次运行的初始配置管理阶段和网络正常运行的工作配置管理阶段；负责网络建设、业务展开和配置维护，达到网络性能最优；包括：设置系统中有关路由操作的参数、被管理对象的名字管理、初始化或关闭被管对象、根据要求收集系统当前状态的有关信息、获取系统重要变化信息、更改系统配置、生成网络拓扑。<br>（2）故障管理：发现和排除故障；维护和监测错误日志；接收错误响应；跟踪辨别错误；<br>（3）性能管理：计算机网络性能；收集统计信息；监控网络使用状况；维护网络使用状况；<br>（4）计费管理<br>（5）安全管理：对授权机制、访问控制、加密和解密关键字的管理。  </p><h3 id="3-网络管理协议"><a href="#3-网络管理协议" class="headerlink" title="3.网络管理协议"></a>3.网络管理协议</h3><p>（1）CMIS和CMIP：由IOS制定；所用功能都要映射到应用层；采用报告机制（委托管理制）；实施复杂且花费高；<br>（2）SNMP：工作在应用层；IETF制定；遵循ISO的管理模型，可以应用于TCP/IP环境下；收集数据的方式有轮询（不断收集，按顺序存储在MIB中，时效低）和基于中断（时效高，需要转发大量信息，消耗管理设备资源时间，改进：trap）两种；SNMP第一版安全性差；第二版提供验证、加密和时间同步机制，在安全性和更有效的传递管理信息方面加以改进；  </p><h3 id="4-信息安全等级"><a href="#4-信息安全等级" class="headerlink" title="4.信息安全等级"></a>4.信息安全等级</h3><p>（1）美国制定（DOD5200.28-STD）：<br>非安全保护类：D（客户机系统）；自主保护类：C1、C2（存取控制，以用户为单位）<br>强制性安全保护类：B1（标记安全保护）B2（结构化安全保护）B3（安全域机制保护）A1<br>（2）中国制定：自主保护级、指导保护级、监督保护级、强制保护级、专控保护级  </p><h3 id="5-OSI安全框架（X-800）中安全攻击类型"><a href="#5-OSI安全框架（X-800）中安全攻击类型" class="headerlink" title="5.OSI安全框架（X.800）中安全攻击类型"></a>5.OSI安全框架（X.800）中安全攻击类型</h3><p>（1）被动攻击：不更改信息，窃听检测，内容泄漏，流量分析（重在预防）；<br>（2）主动攻击：更改信息，消息篡改，DOS攻击，消息重放，拒绝，伪装（重在检测）；<br>（3）服务攻击：针对特定服务攻击；邮件炸弹；端口攻击；分布式拒绝服务攻击；<br>（4）非服务攻击：基于网络层或底层协议漏洞攻击；源路由攻击，地址欺骗，NetXray攻击。  </p><h3 id="6-对称密码"><a href="#6-对称密码" class="headerlink" title="6.对称密码"></a>6.对称密码</h3><p>（1）DES：分组长度64位，分组置换，密钥长度56位；美国NIST采纳；<br>（2）三重DES：多个密钥对DES进行三次加密；<br>（3）高级加密（AES）：分组长度128，分组置换，密钥长度128,192或256位，性能不低三重DES；<br>（4）Blowfish算法：可变长度密钥，分组长度64；<br>（5）RC5：分组长度和密钥长度均变。  </p><h3 id="7-非对称密钥（公钥密码）"><a href="#7-非对称密钥（公钥密码）" class="headerlink" title="7.非对称密钥（公钥密码）"></a>7.非对称密钥（公钥密码）</h3><p>（1）RSA算法：发明者姓名命名；分组密码；加密强度取决于密钥长度（概率加密方法）；质数值越大，破解越难；<br>（2）ElGamal算法：公钥密码体制和椭圆曲线加密体系；基于离散对数；常用于数字签名；密文是明文的两倍。<br>（3）背包加密算法：目前一次背包不安全；  </p><h3 id="8-密钥的验证"><a href="#8-密钥的验证" class="headerlink" title="8.密钥的验证"></a>8.密钥的验证</h3><p>认证中心（CA），验证实体身份；产生证书，将公钥和身份绑定；证书由CA进行数字签名；认证后公钥的发布不受限制；保管用户的公钥；</p><h3 id="9-认证技术"><a href="#9-认证技术" class="headerlink" title="9.认证技术"></a>9.认证技术</h3><p>（1）消息认证的方法：认证消息来源；认证信息的完整性；认证信息的序号和时间。<br>（2）认证模式：单向和双向；<br>（3）认证函数：信息加密函数；信息认证码；散列函数（Hush，消息通过散列函数生成摘要。MD5同步处理可得到128位摘要）<br>（4）数字签名：防止抵赖<br>（5）身份认证：口令认证、持证认证和生物识别；协议有Kerberos（对称密钥；TCP/IP环境下；美国麻省理工）、X.509（公钥体制；CCITT制定） </p><h3 id="10-安全电子邮件（应用层）"><a href="#10-安全电子邮件（应用层）" class="headerlink" title="10.安全电子邮件（应用层）"></a>10.安全电子邮件（应用层）</h3><p>（1）PGP：数字签名采用DSS/SHA或RSA/SHA；压缩：ZIP；兼容：64-BASE<br>（2）S/MIME：支持数据加密和数字签名；  </p><h3 id="11-IPSEC"><a href="#11-IPSEC" class="headerlink" title="11.IPSEC"></a>11.IPSEC</h3><p>网络层安全协议；将互联层改造为逻辑连接的层；主要有身份认证头（AH）协议（对于发送方提供源身份认证和数据完整性，没有提供秘密性）和封装安全负载（ESP）协议（提供源身份认证和数据完整性，提供了秘密性）；源主机与网络主机进行握手并建立网络逻辑连接，该逻辑通道成为安全协议（SA）；SA定义的逻辑连接是单工的，三元组。</p><h3 id="12-防火墙分类"><a href="#12-防火墙分类" class="headerlink" title="12.防火墙分类"></a>12.防火墙分类</h3><p>（1）包过滤路由器：根据IP数据包进行处理，决定转发或丢弃；<br>（2）应用级网关：代理服务器；<br>（3）电路级网关：不允许端到端直接TCP连接；<br>（4）堡垒主机。  </p><h3 id="13-公钥加密和数字签名技术建立的安全基础设施为：PKI"><a href="#13-公钥加密和数字签名技术建立的安全基础设施为：PKI" class="headerlink" title="13.公钥加密和数字签名技术建立的安全基础设施为：PKI"></a>13.公钥加密和数字签名技术建立的安全基础设施为：PKI</h3><h3 id="14-密钥分发中心（KDI）"><a href="#14-密钥分发中心（KDI）" class="headerlink" title="14.密钥分发中心（KDI）"></a>14.密钥分发中心（KDI）</h3><p>是一个独立的可信的服务器；对称密钥；知道每个用户的密文，可一次性方法密钥，与客户通过密文传输。</p><h3 id="15-安全电子交易协议SET"><a href="#15-安全电子交易协议SET" class="headerlink" title="15.安全电子交易协议SET"></a>15.安全电子交易协议SET</h3><p>安全电子交易协议SET是一种应用于Internet环境下，以信用卡为基础的安全电子交付协议，它给出了一套电子交易的过程规范。通过SET协议可以实现电子商务交易中的加密、认证、密钥管理机制等，保证了在Internet上使用信用卡进行电子购物的安全。主要目的是解决信用卡电子付款的安全保障性问题，这包括：保证信息的机密性、保证信息安全传输、不被窃听，只有收件人才能得到和解密信息。（常用于电子商务应用中；防止交易数据被篡改；需要认证中心的支持；验证交易双方的身份）  </p><h1 id="文档下载链接"><a href="#文档下载链接" class="headerlink" title="文档下载链接"></a>文档下载链接</h1><p><strong>下面是此知识点总结文档链接</strong> ，同学们可以下载后慢慢复习呀~  </p><p>链接：<a href="https://pan.baidu.com/s/1m85cEGZj8WRrQ12XiwHTrA">https://pan.baidu.com/s/1m85cEGZj8WRrQ12XiwHTrA</a> 密码：c21v</p><h1 id="计算机四级相关总结链接"><a href="#计算机四级相关总结链接" class="headerlink" title="计算机四级相关总结链接"></a>计算机四级相关总结链接</h1><ol><li><a href="https://sublimerui.top/archives/767f2af2.html">[转]计算机四级网络工程师思维导图–常考重点</a></li><li><a href="https://sublimerui.top/archives/55ffe23a.html">[转]计算机四级网络工程师思维导图–操作系统部分</a></li><li><a href="https://sublimerui.top/archives/5be6111c.html">[转]计算机四级网络工程师思维导图–计算机网络部分</a></li></ol><hr><p><strong>感谢你的耐心阅读呀(๑<em>◡</em>๑)，总结不易，加个收藏点点赞呗~</strong></p><p><strong>你的支持就是我前进的动力呀~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
          <category> 计算机考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机四级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题升级方法（实用！）</title>
      <link href="archives/dfb45bc4.html"/>
      <url>archives/dfb45bc4.html</url>
      
        <content type="html"><![CDATA[<p>最近，自己使用的Hexo博客主题Material-X有新的版本更新，使用普通的方法<code>git clone</code>会覆盖自己修改后的文件，使得DIY的主题丢失。<br>通过查阅有关资料，总结出了以合并文件的形式更新当前的主题文件的方法喔~  </p><a id="more"></a><p><strong>PS</strong>：</p><ol><li><p><code>git pull</code>用法：<a href="https://blog.csdn.net/chaiyu2002/article/details/82120256">https://blog.csdn.net/chaiyu2002/article/details/82120256</a>  </p></li><li><p>最开始更新主题的时候，直接使用<code>git pull</code>命令，然而，出现了报错：  </p></li></ol><blockquote><p>error: Your local changes to the following files would be overwritten by merge:<br>_config.yml<br>Please commit your changes or stash them before you merge.<br>Aborting</p></blockquote><p>原来，pull新版本主题文件的时候，本地的主题文件也DIY修改过，两者文件内容不同，导致发生冲突（即报错中的 _config.yml 文件）。  </p><p>为了解决问题，同时本着无损合并代码的方式更新，在网络上找到了一篇文章。<br>原文出自：<a href="https://www.jianshu.com/p/920ad324fe64">https://www.jianshu.com/p/920ad324fe64</a></p><h2 id="主题更新步骤"><a href="#主题更新步骤" class="headerlink" title="主题更新步骤"></a>主题更新步骤</h2><ol><li>使用<a href="https://git-scm.com/"><strong>Git Bash</strong></a>工具跳转到主题文件对应的目录中，如我的是：</li></ol><blockquote><p>D:\Program Files\Hexo\themes\material-x  </p></blockquote><ol start="2"><li>首先，更新工作的状态树：  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><ol start="3"><li>之后，输入如下命令，将文件放在堆栈中，获取更新后，再弹栈：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>执行这几条简单的命令之后，Hexo主题便可以无损更新。  </p><p><strong>操作截图如下：</strong>  </p><p><img src="https://i.loli.net/2019/08/30/qviIATxeE8OFMPd.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/30/qviIATxeE8OFMPd.png" srcset="data:image/png;base64,666" alt="示意图"></p><h2 id="附：相关Git命令知识"><a href="#附：相关Git命令知识" class="headerlink" title="附：相关Git命令知识"></a>附：相关Git命令知识</h2><p><strong>git add .</strong><br>他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p><strong>git stash</strong><br>能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。  </p><p><strong>git stash save</strong><br>作用等同于git stash，区别是可以加一些注释  </p><p><strong>git stash list</strong><br>查看当前stash中的内容  </p><p><strong>git stash pop</strong><br>将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。<br>注：该命令将堆栈中最近保存的内容删除（栈是先进后出）<br>如果从stash中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。  </p><p><strong>git stash apply</strong><br>将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。<br>堆栈中的内容并没有删除。<br>可以使用git stash apply + stash名字（如stash@{1}）指定恢复哪个stash到当前的工作目录。  </p><p><strong>git stash clear</strong><br>清除堆栈中的所有内容  </p><p><strong>git stash show</strong><br>查看堆栈中最新保存的stash和当前目录的差异。  </p><blockquote><p>通过<code>git stash</code>将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常<code>git pull</code>了，<code>git pull</code>完成后，执行<code>git stash pop</code>将之前本地做的修改应用到当前工作区。</p></blockquote><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，原创总结不易，收藏并评论一下呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019电赛--无人机题目OpenMV总结</title>
      <link href="archives/d508d500.html"/>
      <url>archives/d508d500.html</url>
      
        <content type="html"><![CDATA[<p>2019年电赛，前前后后经历了四天吧。从8月7好开始，到10号结束，浑浑噩噩，不分白昼地为了无人机的题目而努力吧。我的队友负责飞控，我也就负责视觉模块OpenMV程序的编写啦。虽然比赛下来感觉发挥不是特别好，但还是有所收获吧。这里，我把比赛自己用到的相关程序代码贴出来并做了简要总结。  </p><p>无论如何都不能放弃呀！勤做笔记，加油！  </p><p><img src="https://i.loli.net/2019/09/01/zJ8ytaPXqimM7Td.png" class="lazyload" data-srcset="https://i.loli.net/2019/09/01/zJ8ytaPXqimM7Td.png" srcset="data:image/png;base64,666" alt="go"></p><a id="more"></a><p>上一篇相关博文，<strong>准备阶段OpenMV学习笔记链接：<a href="https://sublimerui.top/archives/f10b0e1a.html">https://sublimerui.top/archives/f10b0e1a.html</a></strong></p><h1 id="无人机题目分析"><a href="#无人机题目分析" class="headerlink" title="无人机题目分析"></a>无人机题目分析</h1><p><strong>今年的电赛题目着实让人觉得出题挺新颖的。新颖的同时，困难度就直线提升了（呜呜呜，我们队就是受害者之一，说好的光流可以定点呢，结果那种灰白条纹地面根本就定不住，<del>真的想狠狠地吐槽一下砖家组</del>）</strong>  </p><p>哎，做下来大部分时间懵逼，都是一把辛酸一把泪呀~</p><p>言归正传，今年的电赛无人机题目B题——巡线机器人，具体要求是让我们的无人机从一个杆起飞，沿着线飞向宁一个杆，飞行过程中会拍摄条形码和二维码，绕杆一圈后，再降落。题目如下：  </p><p><img src="https://i.loli.net/2019/08/16/1mbytxXeTfUMODw.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/16/1mbytxXeTfUMODw.png" srcset="data:image/png;base64,666" alt="题目1"><br><img src="https://i.loli.net/2019/08/16/UfvZ3gVPyBmJAO5.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/16/UfvZ3gVPyBmJAO5.png" srcset="data:image/png;base64,666" alt="题目2"><br><img src="https://i.loli.net/2019/08/16/N9XSR86yvMg1YVs.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/16/N9XSR86yvMg1YVs.png" srcset="data:image/png;base64,666" alt="题目3"><br><img src="https://i.loli.net/2019/08/17/Hl1eZWOT9I7VmXg.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/17/Hl1eZWOT9I7VmXg.png" srcset="data:image/png;base64,666" alt="题目4"><br><img src="https://i.loli.net/2019/08/17/Uft3dGCArjkh26g.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/17/Uft3dGCArjkh26g.png" srcset="data:image/png;base64,666" alt="题目5"><br><img src="https://i.loli.net/2019/08/17/EMt9haQgcV8CsRD.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/17/EMt9haQgcV8CsRD.png" srcset="data:image/png;base64,666" alt="题目6"><br><img src="https://i.loli.net/2019/08/17/pWHxcUMsYvVqD6t.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/17/pWHxcUMsYvVqD6t.png" srcset="data:image/png;base64,666" alt="题目7"></p><blockquote><p><strong>PS</strong>:这里附上2019年电赛的各方向题目，已经放在Github上：<a href="https://github.com/cwxyr/nuedc-2019-openmv/blob/master/2019%E7%94%B5%E8%B5%9B%E9%A2%98%E7%9B%AE.zip">2019电赛题目.zip</a></p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>题目中，涉及OpenMV的部分，主要可以分为以下几类吧：  </p><ol><li><p>识别并拍摄条形码和二维码，储存于SD卡中；</p></li><li><p>OpenMV巡线（此方法是由于实际比赛中发现无法用光流在灰白条纹地面上定点，即无法控制其水平方向的误差偏移）  </p><ul><li><p>方法一：识别并拟合两条杆之间线缆的直线，返回偏差距离和偏差角度（缺点：OpenMV视野横向不丢失距离太小了）；  </p></li><li><p>方法二：拟合识别条纹边缘（由于条纹宽度规定了，可以寻找灰白条纹和外部白色地面的交界处），拟合出边缘直线，返回偏差距离和偏差角度（相对来说更稳定，这也是我们队最后用的方法）；</p></li></ul></li><li><p>识别并返回环形圆板中心红点坐标位置，使飞机定圆点（发挥部分）  </p></li><li><p>其他（例如起飞后用OpenMV识别靠杆，识别到特定标志后开始绕杆等等）</p></li></ol><h1 id="逐类型分析"><a href="#逐类型分析" class="headerlink" title="逐类型分析"></a>逐类型分析</h1><h2 id="拍摄条形码和二维码并储存SD卡"><a href="#拍摄条形码和二维码并储存SD卡" class="headerlink" title="拍摄条形码和二维码并储存SD卡"></a>拍摄条形码和二维码并储存SD卡</h2><p>有关于条形码和二维码的讲解我已将在<a href="https://sublimerui.top/archives/f10b0e1a.html">上一篇博文</a>中有所总结和归纳了，这里，直接贴上我写的部分代码吧，全部代码已经放在<a href="https://github.com/cwxyr/nuedc-2019-openmv">我的Github</a>上面了，需要的话可以自己下载呐~</p><p>自己手写的完整程序已放在Github上：**<a href="https://github.com/cwxyr/nuedc-2019-openmv/blob/master/shot_images_to_save.py">shot_images_to_save.py</a>**  </p><ul><li>条形码和二维码拍摄：<br>函数<code>shot_images_while_tracking_lines()</code>用于拍摄并储存找 照片于SD卡中。其中，此段程序会分别对条形码连续循环拍3三张，分别命名为“barcod_1.jpg”，“barcod_2.jpg”和“barcod_3.jpg”（二维码同理），只要OpenMV插上了SD卡后，一旦识别到相关条码后，便会拍摄并自动保存到卡中。<br>完整程序代码中，如果识别到条形码，OpenMV就会闪绿灯拍照；识别到二维码后，OpenMV会闪红灯拍照。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 拍照 ###############</span></span><br><span class="line"></span><br><span class="line">barcode_num = <span class="number">0</span></span><br><span class="line">qrcode_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拍摄照片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_images_while_tracking_lines</span>():</span></span><br><span class="line">    <span class="comment">#global had_finished_barcode, had_finished_qrcode</span></span><br><span class="line">    <span class="keyword">global</span> barcode_detected, qrcode_detected, barcode_num, qrcode_num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> barcode_detected: <span class="comment">#and (not had_finished_barcode):</span></span><br><span class="line">        <span class="comment">#sensor.set_framesize(sensor.QVGA)</span></span><br><span class="line">        <span class="comment">#barcode_detected = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> barcode_num &lt;= <span class="number">3</span>:</span><br><span class="line">            barcode_num += <span class="number">1</span></span><br><span class="line">            barcode_name = <span class="string">&quot;barcode_&quot;</span> + str(barcode_num)</span><br><span class="line">            sensor.snapshot().save(barcode_name + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">            print(barcode_name + <span class="string">&quot;.jpg is saved!&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> barcode_num &gt;= <span class="number">3</span>:</span><br><span class="line">                barcode_num = <span class="number">0</span></span><br><span class="line">                <span class="comment">#barcode_detected = 0</span></span><br><span class="line">                print(<span class="string">&quot;bar:&quot;</span>, barcode_detected)</span><br><span class="line">                <span class="comment">#had_finished_barcode = 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> qrcode_detected: <span class="comment">#and (not had_finished_qrcode):</span></span><br><span class="line">        <span class="comment">#sensor.set_framesize(sensor.QVGA)</span></span><br><span class="line">        <span class="comment">#qrcode_detected = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> qrcode_num &lt;= <span class="number">4</span>:</span><br><span class="line">            qrcode_num += <span class="number">1</span></span><br><span class="line">            qrcode_name = <span class="string">&quot;qrcode_&quot;</span> + str(qrcode_num)</span><br><span class="line">            sensor.snapshot().save(qrcode_name + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">            print(qrcode_name + <span class="string">&quot;.jpg is saved!&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> qrcode_num &gt;= <span class="number">3</span>:</span><br><span class="line">                qrcode_num = <span class="number">0</span></span><br><span class="line">                <span class="comment">#qrcode_detected = 0</span></span><br><span class="line">                print(<span class="string">&quot;qr:&quot;</span>, qrcode_detected)</span><br><span class="line">                <span class="comment">#had_finished_qrcode = 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>识别条形码（识别黄色）和二维码（二值化后计算像素点，设置阈值）：<br>此段程序中，函数<code>count_pixels_with_movement(img)</code>用于识别并判断识别条形码和二维码的条件和阈值。以条形码为例，这里通过色块识别的方法，调用<code>img.find_blobs()</code>函数，通过设置黄色阈值，达到识别到黄色条码的目的。其中，<code>barcode_pixels_threshold</code>是一个列表，储存的2个元素分别是黄色阈值下限和上限。<br>此外，我也尝试运用统计像素点的方式去识别二维码和条形码（这里已经被注释掉），其方法是先将图像按照一定的阈值二值化后，调用<code>img.get_pixel()</code>函数，统计满足像素值为255（即白色）的像素个数，同时，设定特定的像素阈值（如<code>qrcode_pixels_threshold</code>等等，与黄色检测同理，也有阈值上下限两个阈值），也可以达到同样的效果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 像素识别 ###########</span></span><br><span class="line"></span><br><span class="line">barcode_cnt = <span class="number">0</span></span><br><span class="line">qrcode_cnt = <span class="number">0</span></span><br><span class="line">pole_cnt = <span class="number">0</span></span><br><span class="line">LED_ON = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_pixels_with_movement</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="keyword">global</span> x_width, y_height</span><br><span class="line">    <span class="keyword">global</span> barcode_detected, qrcode_detected</span><br><span class="line">    <span class="keyword">global</span> barcode_cnt, qrcode_cnt, pole_cnt</span><br><span class="line">    <span class="keyword">global</span> LED_ON</span><br><span class="line"></span><br><span class="line">    blob = img.find_blobs(barcode_pixels_threshold, pixels_threshold=<span class="number">150</span>, area_threshold=<span class="number">150</span>, merge=<span class="literal">True</span>, margin=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> blob:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> blob:</span><br><span class="line">            img.draw_rectangle(i.rect(), color = <span class="number">127</span>)</span><br><span class="line">            barcode_detected = <span class="number">1</span></span><br><span class="line">            LED_ON = <span class="number">1</span></span><br><span class="line">            print(<span class="string">&quot;132123132131313131112311231&quot;</span>) <span class="comment">#测试用，可删除</span></span><br><span class="line">            print(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        barcode_detected = <span class="number">0</span></span><br><span class="line">        LED_ON = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    x_pos = <span class="number">0</span></span><br><span class="line">    y_pos = <span class="number">0</span></span><br><span class="line">    total_white_pixels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_pos <span class="keyword">in</span> range(x_width):</span><br><span class="line">        <span class="keyword">for</span> y_pos <span class="keyword">in</span> range(y_height):</span><br><span class="line">            <span class="keyword">if</span> img.get_pixel(x_pos, y_pos) == <span class="number">255</span>:</span><br><span class="line">                total_white_pixels += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(&quot;total white pixels are&quot;, total_white_pixels)</span></span><br><span class="line"><span class="comment">#    if total_white_pixels &gt;= verticle_pixels_threshold[0] and \</span></span><br><span class="line"><span class="comment">#            total_white_pixels &lt;= verticle_pixels_threshold[1]:       #直角</span></span><br><span class="line"><span class="comment">#        singleline_check.is_verticle = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    elif total_white_pixels &gt;= track_line_pixels_threshold[0] and \</span></span><br><span class="line"><span class="comment">#            total_white_pixels &lt;= track_line_pixels_threshold[1]:     #巡线</span></span><br><span class="line"><span class="comment">#        singleline_check.is_verticle = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total_white_pixels &gt;= barcode_pixels_threshold[<span class="number">0</span>] <span class="keyword">and</span> \</span><br><span class="line">            total_white_pixels &lt;= barcode_pixels_threshold[<span class="number">1</span>]:        <span class="comment">#条形码</span></span><br><span class="line">       <span class="keyword">if</span> barcode_cnt &gt;= <span class="number">0</span> <span class="keyword">and</span> barcode_cnt &lt;= <span class="number">49</span>:</span><br><span class="line">            barcode_cnt += <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> barcode_cnt == <span class="number">50</span>:</span><br><span class="line">            barcode_cnt = <span class="number">-1</span></span><br><span class="line">            barcode_detected = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#        LED(1).toggle()  #红灯</span></span><br><span class="line">    <span class="comment">#        time.sleep(200)</span></span><br><span class="line">    <span class="comment">#        LED(1).toggle()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#if total_white_pixels &gt;= qrcode_pixels_threshold[0] and \</span></span><br><span class="line">    <span class="comment">#        total_white_pixels &lt;= qrcode_pixels_threshold[1]:         #二维码</span></span><br><span class="line">    <span class="comment">#    if qrcode_cnt &gt;= 0 and qrcode_cnt &lt;= 49:</span></span><br><span class="line">    <span class="comment">#        qrcode_cnt += 1</span></span><br><span class="line">    <span class="comment">#    if qrcode_cnt == 50:</span></span><br><span class="line">    <span class="comment">#        qrcode_cnt = -1</span></span><br><span class="line">    <span class="comment">#        qrcode_detected = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#        LED(3).toggle()   #蓝灯</span></span><br><span class="line">    <span class="comment">#        time.sleep(200)</span></span><br><span class="line">    <span class="comment">#        LED(3).toggle()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#elif total_white_pixels &gt;= near_the_pole_threshold[0] and \</span></span><br><span class="line">    <span class="comment">#        total_white_pixels &lt;= near_the_pole_threshold[1]:         #到达杆</span></span><br><span class="line">    <span class="comment">#    if pole_cnt &gt;= 0 and pole_cnt &lt;= 49:</span></span><br><span class="line">    <span class="comment">#        pole_cnt += 1</span></span><br><span class="line">    <span class="comment">#    if pole_cnt == 50:</span></span><br><span class="line">    <span class="comment">#        pole_cnt = -1</span></span><br><span class="line">    <span class="comment">#        send_flag.pole_is_near = 1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;the flags are: %d %d %d&quot;</span>%(barcode_detected, qrcode_detected, send_flag.pole_is_near))   <span class="comment">#测试用，可删除</span></span><br></pre></td></tr></table></figure><h2 id="OpenMV巡线"><a href="#OpenMV巡线" class="headerlink" title="OpenMV巡线"></a>OpenMV巡线</h2><p>自己手写的完整程序已放在Github上：**<a href="https://github.com/cwxyr/nuedc-2019-openmv/blob/master/detect_and_track_edges.py">detect_and_track_edges.py</a>**</p><h3 id="方法一（拟合两杆间直线）"><a href="#方法一（拟合两杆间直线）" class="headerlink" title="方法一（拟合两杆间直线）"></a>方法一（拟合两杆间直线）</h3><p>巡线的时候，使用的是最小二乘法的线性回归算法，即运用<code>img.get_regression()</code>函数（这里打开了鲁棒算法<code>robust = True</code>，效果更好），计算其拟合直线后的结果，并拥有两个返回值（误差偏离值<code>singleline_check.flag2.rho()</code>和偏角值<code>singleline_check.flag2.theta()</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">found_line</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="comment">#对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。 若 robust 为True，则将</span></span><br><span class="line">    <span class="comment">#使用泰尔指数。泰尔指数计算图像中所有阈值像素间的所有斜率的中值。thresholds：追踪的颜色范围</span></span><br><span class="line">    singleline_check.flag2 = img.get_regression([(<span class="number">255</span>,<span class="number">255</span>)], robust = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> (singleline_check.flag2):</span><br><span class="line">        <span class="comment">#print(clock.fps())</span></span><br><span class="line">        singleline_check.rho_err = abs(singleline_check.flag2.rho())<span class="number">-0</span> <span class="comment">#求解线段偏移量的绝对值</span></span><br><span class="line">        <span class="keyword">if</span> singleline_check.flag2.theta()&gt;<span class="number">90</span>: <span class="comment">#求解角度的偏移量</span></span><br><span class="line">            singleline_check.theta_err = singleline_check.flag2.theta()<span class="number">-0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singleline_check.theta_err = singleline_check.flag2.theta()<span class="number">-0</span></span><br><span class="line">        <span class="comment">#在图像中画一条直线。singleline_check.flag2.line()意思是(x0, y0)到(x1, y1)的直线；颜色可以是灰度值(0-255)，或者是彩色值</span></span><br><span class="line">        <span class="comment">#(r, g, b)的tupple，默认是白色</span></span><br><span class="line">        img.draw_line(singleline_check.flag2.line(), color = <span class="number">127</span>)</span><br><span class="line">        <span class="comment">#print(singleline_check.theta_err)</span></span><br></pre></td></tr></table></figure><p>拟合示意图如下，（其中，红色的为拟合直线）：</p><p><img src="https://i.loli.net/2019/08/21/uAZgSI6bPDifNhR.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/21/uAZgSI6bPDifNhR.png" srcset="data:image/png;base64,666" alt="拟合示意图"></p><blockquote><p><strong>PS</strong>：此方法准确度较高，但是OpenMV图像视野范围有限。当直线从图像视野最下端到达最上端，换算成无人机横向移动的距离仅有5-10cm，当无人机超出此范围时，将无法获取直线了，有一定的局限性。</p></blockquote><h3 id="方法二（拟合识别条纹边缘）"><a href="#方法二（拟合识别条纹边缘）" class="headerlink" title="方法二（拟合识别条纹边缘）"></a>方法二（拟合识别条纹边缘）</h3><p>此函数<code>track_edges(img)</code>中，同样使用<code>img.find_blobs()</code>找色块的方法，其中运用了简单角度和距离的计算方法。并返回条纹底色边界线的拟合直线，此函数的计算结果为拟合直线距离画面左边界距离<code>rho</code>和中心线的偏离角度<code>theta</code>。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">track_edges</span>(<span class="params">img</span>):</span> <span class="comment">#invert = True</span></span><br><span class="line">    blobs = img.find_blobs([edge_thresholds], pixels_threshold=<span class="number">50</span>, area_threshold=<span class="number">50</span>, merge=<span class="literal">False</span>, margin=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> blobs:</span><br><span class="line">        sum_x = <span class="number">0</span></span><br><span class="line">        sum_theta = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(blobs)):</span><br><span class="line">            img.draw_rectangle(blobs[i].rect(), color = <span class="number">127</span>)</span><br><span class="line">            sum_x += (blobs[i].x() + blobs[i].w())</span><br><span class="line">            sum_theta += math.degrees(blobs[i].rotation())</span><br><span class="line"></span><br><span class="line">        per_x = sum_x / len(blobs)</span><br><span class="line">        per_y = y_height / <span class="number">2</span></span><br><span class="line">        per_theta = sum_theta / len(blobs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> per_theta &gt;= <span class="number">0</span> <span class="keyword">and</span> per_theta &lt; <span class="number">90</span>:</span><br><span class="line">            true_theta = <span class="number">90</span> - per_theta</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> per_theta &gt;= <span class="number">90</span> <span class="keyword">and</span> per_theta &lt;<span class="number">180</span>:</span><br><span class="line">            true_theta = (<span class="number">180</span> - per_theta) + <span class="number">90</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;per_x: %d per_y: %d true_theta: %d&quot;</span>%(per_x, per_y, true_theta))</span><br><span class="line">        horizontal_line = (int(per_x), int(per_y), <span class="number">0</span>, int(per_y))</span><br><span class="line">        centre_cross    = (int(per_x), int(per_y))</span><br><span class="line"></span><br><span class="line">        img.draw_line(horizontal_line, color = <span class="number">127</span>)</span><br><span class="line">        img.draw_cross(centre_cross, color = <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line">        singleline_check.rho_err = int(per_x)</span><br><span class="line">        singleline_check.theta_err = int(true_theta)</span><br><span class="line"></span><br><span class="line">    line.flag = <span class="number">1</span></span><br><span class="line">    uart.write(pack_linetrack_data())</span><br></pre></td></tr></table></figure><p>拟合示意图如下（其中，红色的为拟合直线）：</p><p><img src="https://i.loli.net/2019/08/21/x9vfbNuUJ3sOI2t.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/21/x9vfbNuUJ3sOI2t.png" srcset="data:image/png;base64,666" alt="拟合示意图"></p><p>这样，当检测到条纹边界的时候，会计算拟合出条纹边界的直线。  </p><blockquote><p><strong>PS</strong>：注意，使用这种方法一定要打开白平衡和自动增益！！！非常重要！！！我们队就吃了这样的亏，使得OpenMV距离地面较近的时候识别正常，一旦远离地面一定距离后，图像中将无法识别边界直线！！！  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在这里，应该将自动增益和白平衡打开</span></span><br><span class="line">sensor.set_auto_gain(<span class="literal">True</span>)</span><br><span class="line">sensor.set_auto_whitebal(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="飞机悬停定圆点"><a href="#飞机悬停定圆点" class="headerlink" title="飞机悬停定圆点"></a>飞机悬停定圆点</h2><p>定特定颜色的原点时，将运用<code>img.find_blobs()</code>函数（这里将图像二值化了），返回色块其中心坐标<code>cx()</code>和<code>cy()</code>即可。对于不同的颜色的色块（如题目中的红色），需要实地测试得到不同的阈值。<br>这里的返回值为圆点中心坐标、像素大小和标志位。</p><p><img src="https://i.loli.net/2019/08/21/GakNHxnl5Ee9Qow.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/21/GakNHxnl5Ee9Qow.png" srcset="data:image/png;base64,666" alt="圆点"></p><p>自己手写的完整程序已放在Github上：<a href="https://github.com/cwxyr/nuedc-2019-openmv/blob/master/main.py">main.py</a></p><p>找圆点函数：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_dot</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="comment">#thresholds为黑色物体颜色的阈值，是一个元组，需要用括号［ ］括起来可以根据不同的颜色阈值更改；pixels_threshold 像素个数阈值，</span></span><br><span class="line">    <span class="comment">#如果色块像素数量小于这个值，会被过滤掉area_threshold 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉；merge 合并，如果</span></span><br><span class="line">    <span class="comment">#设置为True，那么合并所有重叠的blob为一个；margin 边界，如果设置为5，那么两个blobs如果间距5一个像素点，也会被合并。</span></span><br><span class="line">    <span class="keyword">for</span> blob <span class="keyword">in</span> img.find_blobs(thresholds, pixels_threshold=<span class="number">80</span>, area_threshold=<span class="number">80</span>, merge=<span class="literal">True</span>, margin=<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> dot.pixels&lt;blob.pixels():<span class="comment">#寻找最大的黑点</span></span><br><span class="line">            <span class="comment">##先对图像进行分割，二值化，将在阈值内的区域变为白色，阈值外区域变为黑色</span></span><br><span class="line">            img.binary(thresholds)</span><br><span class="line">            <span class="comment">#对图像边缘进行侵蚀，侵蚀函数erode(size, threshold=Auto)，size为kernal的大小，去除边缘相邻处多余的点。threshold用</span></span><br><span class="line">            <span class="comment">#来设置去除相邻点的个数，threshold数值越大，被侵蚀掉的边缘点越多，边缘旁边白色杂点少；数值越小，被侵蚀掉的边缘点越少，边缘</span></span><br><span class="line">            <span class="comment">#旁边的白色杂点越多。</span></span><br><span class="line">            img.erode(<span class="number">2</span>)</span><br><span class="line">            dot.pixels=blob.pixels() <span class="comment">#将像素值赋值给dot.pixels</span></span><br><span class="line">            dot.x = blob.cx() <span class="comment">#将识别到的物体的中心点x坐标赋值给dot.x</span></span><br><span class="line">            dot.y = blob.cy() <span class="comment">#将识别到的物体的中心点x坐标赋值给dot.x</span></span><br><span class="line">            dot.ok= <span class="number">1</span></span><br><span class="line">            <span class="comment">#在图像中画一个十字；x,y是坐标；size是两侧的尺寸；color可根据自己的喜好设置</span></span><br><span class="line">            img.draw_cross(dot.x, dot.y, color=<span class="number">127</span>, size = <span class="number">10</span>)</span><br><span class="line">            <span class="comment">#在图像中画一个圆；x,y是坐标；5是圆的半径；color可根据自己的喜好设置</span></span><br><span class="line">            img.draw_circle(dot.x, dot.y, <span class="number">5</span>, color = <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">&quot;centre_x = %d, centre_y = %d&quot;</span>%(dot.x, dot.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断标志位 赋值像素点数据</span></span><br><span class="line">    dot.flag = dot.ok</span><br><span class="line">    dot.num = dot.pixels</span><br><span class="line"></span><br><span class="line">    <span class="comment">#清零标志位</span></span><br><span class="line">    dot.pixels = <span class="number">0</span></span><br><span class="line">    dot.ok = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>剩下的其他功能自己就没有写啦(T＿T)，比赛四天太紧张了，这样已经很不错了，已经是全部成果~</strong></p></blockquote><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，原创总结不易，收藏并评论一下呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
            <tag> OpenMV </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CenOS 7环境下使用WordPress搭建电协官网--（1）基础配置</title>
      <link href="archives/826b26c7.html"/>
      <url>archives/826b26c7.html</url>
      
        <content type="html"><![CDATA[<p>因下学期电协招新及20周年纪念的需要，需要搭建一个官方网站。我们以WordPress为例，介绍从购买一个服务器开始，到安装博客程序以及最后细节优化及注意事项。  </p><p><img src="https://i.loli.net/2019/07/31/5d414ae98e34945456.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d414ae98e34945456.jpg" srcset="data:image/png;base64,666" alt="cover"></p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol><li><p>一个阿里云或者腾讯云服务器 </p></li><li><p>宝塔面板</p></li><li><p>CenOS 7+ 系统</p></li><li><p>LAMP/LNMP环境</p></li><li><p>WordPress安装包</p></li><li><p>远程连接工具Xshell和Xftp</p></li></ol><hr><h1 id="购买并配置服务器"><a href="#购买并配置服务器" class="headerlink" title="购买并配置服务器"></a>购买并配置服务器</h1><p>对于大多数国内用户来说，我们可以选着阿里云或者腾讯云的服务器，这里以选择腾讯云服务器为例，进入<a href="https://cloud.tencent.com/">腾讯云</a>，注册并登录后进入管理后台。在<code>云产品</code>中选择<code>云服务器</code>：  </p><p><img src="https://i.loli.net/2019/07/31/5d419d3f30d7127999.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d419d3f30d7127999.png" srcset="data:image/png;base64,666" alt="腾讯云1"></p><p>之后，在云服务器里面选择<code>创建</code>：  </p><p><img src="https://i.loli.net/2019/07/31/5d419dd53cadd16616.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d419dd53cadd16616.png" srcset="data:image/png;base64,666" alt="腾讯云2"></p><p>选择适当的配置，我们可以选择<code>快速配置</code>，可以按照如下配置购买，其中推荐使用CentOS系统，相对来说较为稳定。</p><p><img src="https://i.loli.net/2019/07/31/5d41a02986fd693847.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d41a02986fd693847.png" srcset="data:image/png;base64,666" alt="腾讯云3"></p><p>购买后，选择左边的<code>SSH密钥</code>，新建后并下载（如我命名为xshell）</p><p><img src="https://i.loli.net/2019/07/31/5d41a5462cda531468.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d41a5462cda531468.png" srcset="data:image/png;base64,666" alt="SSH密钥1"></p><p>返回<code>实例</code>页面，点击右侧<code>更多</code>-&gt;<code>密码/密钥</code>-&gt;<code>加载密钥</code>，选择之前创建的密钥后，将会强制关机以绑定密钥。</p><p><img src="https://i.loli.net/2019/07/31/5d41a660dfdf127999.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/31/5d41a660dfdf127999.png" srcset="data:image/png;base64,666" alt="SSH密钥2"></p><hr><h1 id="下载Xshell和Xftp并远程连接"><a href="#下载Xshell和Xftp并远程连接" class="headerlink" title="下载Xshell和Xftp并远程连接"></a>下载Xshell和Xftp并远程连接</h1><ol><li>Xshell<a href="https://www.netsarang.com/zh/xshell-download/">下载地址</a></li><li>Xftp<a href="https://www.netsarang.com/zh/xftp-download/">下载地址</a></li></ol><h2 id="配置Xshell"><a href="#配置Xshell" class="headerlink" title="配置Xshell"></a>配置Xshell</h2><p>以下载Xshell为例，进入官网后右边有<code>免费授权页面</code>，填写相关信息后，收到回复邮件，打开链接即可免费下载（Xftp同理）  </p><p><img src="https://i.loli.net/2019/08/04/m6erVNJikGXWtA3.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/m6erVNJikGXWtA3.png" srcset="data:image/png;base64,666" alt="Xshell免费下载">  </p><p>下载并安装Xshell和Xftp后，点击<code>文件</code>-&gt;<code>新建</code>，在“连接”窗口，填写的<code>主机</code>为腾讯云服务器外网IP地址，在“用户身份验证”窗口，选择<code>方法</code>为“Public Key”,<code>用户名</code>为root，用户密钥选择之前下载的SSH密钥，点击<code>连接</code>即可成功连接至腾讯云服务器：</p><p><img src="https://i.loli.net/2019/08/04/69ZH51GmLwBqsgj.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/69ZH51GmLwBqsgj.png" srcset="data:image/png;base64,666" alt="shell配置1">  </p><p><img src="https://i.loli.net/2019/08/04/rMlsa57UfcbCTWO.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/rMlsa57UfcbCTWO.png" srcset="data:image/png;base64,666" alt="shell配置2"></p><p>连接成功后的界面如下：  </p><p><img src="https://i.loli.net/2019/08/04/qUBsvOgzDV1a5Tr.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/qUBsvOgzDV1a5Tr.png" srcset="data:image/png;base64,666" alt="shell连接成功">  </p><h2 id="配置Xftp"><a href="#配置Xftp" class="headerlink" title="配置Xftp"></a>配置Xftp</h2><p>配置方法与Xshell类似，这里放上几张配置截图：  </p><p><img src="https://i.loli.net/2019/08/04/qhubmzMlQOISoE8.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/qhubmzMlQOISoE8.png" srcset="data:image/png;base64,666" alt="ftp配置">  </p><p><img src="https://i.loli.net/2019/08/04/fNnRMyYxqu8BWbC.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/fNnRMyYxqu8BWbC.png" srcset="data:image/png;base64,666" alt="ftp连接成功">  </p><p><strong>如果你已经实现了上述结果，恭喜你，远程连接已配置成功。</strong></p><p><strong>PS:<br>使用Xshell需要涉及Linux命令相关的知识。如不是很了解，建议点击这里的<a href="https://www.runoob.com/linux/linux-command-manual.html">传送门</a>了解基本命令。</strong></p><hr><h1 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h1><p>安装宝塔面板主要是为了方便后期维护的方便，使得服务器配置可视化同时加快配置效率。  </p><p>宝塔面板<a href="https://www.bt.cn/">官方网站</a> </p><p><strong>PS：安装宝塔面板时，一定要保证系统纯净，即服务器中没有安装其他的任何软件，否则可能会安装失败！！！</strong>   </p><h2 id="放行出站入站端口"><a href="#放行出站入站端口" class="headerlink" title="放行出站入站端口"></a>放行出站入站端口</h2><p>在安装面板之前，需要放行特定的入站和出站端口号。回到腾讯云管理界面，选择<code>安全组</code>-&gt;<code>新建</code>： </p><p><img src="https://i.loli.net/2019/08/04/ptxE3DG1CuNWMzO.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/ptxE3DG1CuNWMzO.png" srcset="data:image/png;base64,666" alt="安全组1"></p><p>然后下载规则配置文件：  </p><p><a href="https://www.bt.cn/bbs/forum.php?mod=attachment&aid=NDExOHwyYTI5ZWM1NnwxNTY0ODUwMzQ4fDB8MTIyOQ==">sg_input_rules.xlsx</a></p><p><a href="https://www.bt.cn/bbs/forum.php?mod=attachment&aid=NDExOXxkZGE5M2NlNHwxNTY0ODUwMzQ4fDB8MTIyOQ==">sg_output_rules.xlsx</a> </p><p>点击<code>导入规则</code>，将规则配置文件添加到入站和出站规则中：</p><p><img src="https://i.loli.net/2019/08/04/kPi3QZyUNjYF5XM.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/kPi3QZyUNjYF5XM.png" srcset="data:image/png;base64,666" alt="入站和出站规则1"></p><p>之后，点击<code>关联实例</code>-&gt;<code>新增关联</code>，将规则和服务器相互关联。</p><p><img src="https://i.loli.net/2019/08/04/h2AovOxpckI5RLz.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/h2AovOxpckI5RLz.png" srcset="data:image/png;base64,666" alt="关联实例"></p><h2 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h2><p>打开之前配置好的Xshell，对于CenOS 7+的系统，输入如下命令安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><p>出现提示信息，询问是否安装宝塔面板，输入<code>y</code>并回车：</p><p><img src="https://i.loli.net/2019/08/04/I7OYQWmrZpB3lgA.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/I7OYQWmrZpB3lgA.png" srcset="data:image/png;base64,666" alt="安装"></p><p>耐心等待片刻后，出现如下界面，则安装成功。</p><p><img src="https://i.loli.net/2019/08/04/PADRNi4qGy5ml1g.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/PADRNi4qGy5ml1g.png" srcset="data:image/png;base64,666" alt="成功"></p><p>其中，给出了登录名和密码，登录地址为<code>http://你的IP或域名地址:8888/安全入口地址</code>的格式。浏览器输入登录地址并登录。如出现如下后台界面，则安装成功！！！</p><p><img src="https://i.loli.net/2019/08/04/YMI4SZxPqzpRneL.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/04/YMI4SZxPqzpRneL.png" srcset="data:image/png;base64,666" alt="宝塔面板"></p><p>至此，<strong>服务器的基础配置已基本完成</strong>。建议到<code>面板设置</code>修改登录名和密码，便于记忆。</p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，原创不易，收藏并评论一下呗~</p><p>接下来，我们可以配置服务器和安装WordPress等后续操作啦~</p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 电协官网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用的图片上传工具--PicGo</title>
      <link href="archives/5af88fad.html"/>
      <url>archives/5af88fad.html</url>
      
        <content type="html"><![CDATA[<p>博客写多了，有了图片加载慢的问题。这里分享一个简单实用的图片上传工具——PicGo<br>此工具可以一键上传图片，对于编写博客和网站来说很有帮助。  </p><a id="more"></a><h1 id="写在前面…"><a href="#写在前面…" class="headerlink" title="写在前面…"></a>写在前面…</h1><p>刚开始学习网页前端和博客搭建的时候，自己按照网上的教程一步步地学习。但后来，总会遇到一个问题：  </p><blockquote><p>随着网页一步步地完善，图片也越来越多，图片的杂余，使得打开一个页面的时候，总会非常的缓慢（将大部分时间都花在了图片的加载上）  </p></blockquote><h2 id="为什么会这样呢"><a href="#为什么会这样呢" class="headerlink" title="为什么会这样呢"></a>为什么会这样呢</h2><p>原来，随着图片的增多，服务器的压力就会加大，加载网页代码的同时，也会加载图片，然而图片常常很大（几百K到5M大小不等），会有一个很长的加载过程。</p><h2 id="怎么改进呢"><a href="#怎么改进呢" class="headerlink" title="怎么改进呢"></a>怎么改进呢</h2><p>后来，我了解到可以通过<a href="https://baike.baidu.com/item/CDN">CDN</a>的方式来减轻服务器的压力。</p><p><strong>PS:何为CDN？</strong><br>CDN简单通俗地来说，就是通过外链的方式，将脚本、图片、视频等文件链接到自己的服务器，这样，将占用自己服务器资源的文件放在其他的服务器中，以达到网页加速的目的。  </p><p>国内有很多CDN的提供商，例如阿里云、腾讯云、七牛云、又拍云（其中七牛云和又拍云提供定量的免费储存空间）。  </p><p>开始，我使用的是七牛云的对象储存空间，<a href="https://www.qiniu.com/">七牛云</a>有10G的免费空间,但是有一个不便却来了：我需要每次打开七牛的管理后台，手动上传之后，再把链接复制下来，引用到我的博客文章中。这样效率真的很低下，使得图片上传的不便。</p><h1 id="偶然一次的发现——图床工具"><a href="#偶然一次的发现——图床工具" class="headerlink" title="偶然一次的发现——图床工具"></a>偶然一次的发现——图床工具</h1><p><strong>PS:何为图床？</strong><br>图床简单来讲就是图片托管和储存地，即前面所说的CDN提供商（他们既有CDN又有对象存储，即图床）。</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>软件下载链接：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a><br>Github: <a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p><fancybox><img src="https://i.loli.net/2019/07/27/5d3bee7bf416469210.png" class="lazyload" data-srcset="https://i.loli.net/2019/07/27/5d3bee7bf416469210.png" srcset="data:image/png;base64,666" alt="PicGo"></fancybox></p><p>在这里，我们可以选择SM.MS、腾讯云、微博、Github、七牛、Imgur、阿里云和又拍云多种方式上传。<br>上传后，可以自动得到复制链接，粘贴到文章里面即可(oﾟ▽ﾟ)o  </p><p>这里，强力推荐<a href="https://sm.ms/">SM.MS</a>，免费而且速度又快，真的是不二之选！！！！</p><p>就到这里啦，下次更新ヾ(◍°∇°◍)ﾉﾞ</p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，原创总结不易，收藏并评论一下呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019电赛--OpenMV学习笔记</title>
      <link href="archives/f10b0e1a.html"/>
      <url>archives/f10b0e1a.html</url>
      
        <content type="html"><![CDATA[<p>第二年参加电赛了，今年来到测控无人机方向，主要记录一些OpenMV学习经历。<br>再苦逼也要加油呀！！！</p><p><img src="https://i.loli.net/2019/08/06/iUhr5mpMwbkoePK.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/08/06/iUhr5mpMwbkoePK.jpg" srcset="data:image/png;base64,666" alt="封面"></p><a id="more"></a><p>之前，19年电赛视觉模块始终不明朗，直到最近才确定<a href="https://bbs.nuedc-training.com.cn/thread-691-1-1.html">不能用树莓派</a>。于是，一直研究OpenMV的我终于放心了。（哈哈哈这个当然是题外话，吐槽一下）</p><h1 id="正题–OpenMV"><a href="#正题–OpenMV" class="headerlink" title="正题–OpenMV"></a>正题–OpenMV</h1><p><a href="https://book.openmv.cc/">OpenMV</a>是基于嵌入式STM32单片机的基础上，经过层层封装之后，运用microPython语法开发的模块。哈哈哈稍微介绍一下，小白们可以看看…  </p><p>这是我们队用的OpenMV mini的板子：<br><img src="https://i.loli.net/2019/07/27/5d3b25173cdff94492.jpg" class="lazyload" data-srcset="https://i.loli.net/2019/07/27/5d3b25173cdff94492.jpg" srcset="data:image/png;base64,666" alt="IMG_20190726_201841.jpg">  </p><h2 id="寻找直角（或特定角度）"><a href="#寻找直角（或特定角度）" class="headerlink" title="寻找直角（或特定角度）"></a>寻找直角（或特定角度）</h2><h3 id="方法一：寻找两条线交点，从而算出角度值（-已经弃用-）"><a href="#方法一：寻找两条线交点，从而算出角度值（-已经弃用-）" class="headerlink" title="方法一：寻找两条线交点，从而算出角度值（**已经弃用**）"></a>方法一：寻找两条线交点，从而算出角度值（**<del>已经弃用</del>**）</h3><blockquote><p><strong>为什么弃用呢？</strong>  </p></blockquote><ol><li><p>经过我们的测试，此方法存在检测到直角后不准确的问题。特别是当线的区域很大的时候，直角区域也会变大，运用此算法无法十分确切地找到直角顶点的中心位置，即识别出的交点会在直角附近来回抖动，这对于无人机来说，十分的不利，特别是速度快了以后，由于直角交点十分不稳定，很容易炸机。</p></li><li><p>同时，对于此方法，只能检测到特定角度的两条线相交的一个角度，适用性较窄。如需要识别其他类型的特征区域时（如双轨切换、T字和十字路口），就需要另外编写一套程序。</p></li></ol><hr><p><strong>下面是原文….</strong></p><hr><p>由于电赛视觉模块寻迹的原因，可能会涉及无人机直角转弯的问题，通过查找网上资料，获得了如下Python代码,感觉有一定的参考价值：</p><p>通过这个程序，我发现可以调用<code>calculate_angle(line1, line2)</code>函数得出偏角值，调用<code>calculate_intersection(line1, line2)</code>函数得出当前x和y的坐标值<code>(cross_x, cross_y)</code>，这样，再通过串口将对应的数据帧发送给飞控，在飞控端再进行帧格式解析，得出对应的数据后，在进行飞机相应的姿态调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_angle</span>(<span class="params">line1, line2</span>):</span></span><br><span class="line">    <span class="comment"># 利用四边形的角公式， 计算出直线夹角</span></span><br><span class="line">    angle  = (<span class="number">180</span> - abs(line1.theta() - line2.theta()))</span><br><span class="line">    <span class="keyword">if</span> angle &gt; <span class="number">90</span>:</span><br><span class="line">        angle = <span class="number">180</span> - angle</span><br><span class="line">    <span class="keyword">return</span> angle</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_intersection</span>(<span class="params">line1, line2</span>):</span></span><br><span class="line">    <span class="comment"># 计算两条线的交点</span></span><br><span class="line">    a1 = line1.y2() - line1.y1()</span><br><span class="line">    b1 = line1.x1() - line1.x2()</span><br><span class="line">    c1 = line1.x2()*line1.y1() - line1.x1()*line1.y2()</span><br><span class="line"></span><br><span class="line">    a2 = line2.y2() - line2.y1()</span><br><span class="line">    b2 = line2.x1() - line2.x2()</span><br><span class="line">    c2 = line2.x2() * line2.y1() - line2.x1()*line2.y2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1 * b2 - a2 * b1) != <span class="number">0</span> <span class="keyword">and</span> (a2 * b1 - a1 * b2) != <span class="number">0</span>:</span><br><span class="line">        cross_x = int((b1*c2-b2*c1)/(a1*b2-a2*b1))</span><br><span class="line">        cross_y = int((c1*a2-c2*a1)/(a1*b2-a2*b1))</span><br><span class="line">        <span class="keyword">return</span> (cross_x, cross_y)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>下面附上完整源代码：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find Lines Example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows off how to find lines in the image. For each line object</span></span><br><span class="line"><span class="comment"># found in the image a line object is returned which includes the line&#x27;s rotation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: Line detection is done by using the Hough Transform:</span></span><br><span class="line"><span class="comment"># http://en.wikipedia.org/wiki/Hough_transform</span></span><br><span class="line"><span class="comment"># Please read about it above for more information on what `theta` and `rho` are.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find_lines() finds infinite length lines. Use find_line_segments() to find non-infinite lines.</span></span><br><span class="line"></span><br><span class="line">enable_lens_corr = <span class="literal">False</span> <span class="comment"># turn on for straighter lines...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE) <span class="comment"># grayscale is faster</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># min_degree = 0 # 直线最小角度</span></span><br><span class="line"><span class="comment"># max_degree = 179 # 直线最大角度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为直角的阈值</span></span><br><span class="line">right_angle_threshold = (<span class="number">70</span>, <span class="number">90</span>)</span><br><span class="line">binary_threshold = [(<span class="number">0</span>, <span class="number">60</span>)]</span><br><span class="line">forget_ratio = <span class="number">0.8</span></span><br><span class="line">move_threshold = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_angle</span>(<span class="params">line1, line2</span>):</span></span><br><span class="line">    <span class="comment"># 利用四边形的角公式， 计算出直线夹角</span></span><br><span class="line">    angle  = (<span class="number">180</span> - abs(line1.theta() - line2.theta()))</span><br><span class="line">    <span class="keyword">if</span> angle &gt; <span class="number">90</span>:</span><br><span class="line">        angle = <span class="number">180</span> - angle</span><br><span class="line">    <span class="keyword">return</span> angle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_right_angle</span>(<span class="params">line1, line2</span>):</span></span><br><span class="line">    <span class="keyword">global</span> right_angle_threshold</span><br><span class="line">    <span class="comment"># 判断两个直线之间的夹角是否为直角</span></span><br><span class="line">    angle = calculate_angle(line1, line2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> angle &gt;= right_angle_threshold[<span class="number">0</span>] <span class="keyword">and</span> angle &lt;=  right_angle_threshold[<span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># 判断在阈值范围内</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_verticle_lines</span>(<span class="params">lines</span>):</span></span><br><span class="line">    line_num = len(lines)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(line_num <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, line_num):</span><br><span class="line">            <span class="keyword">if</span> is_right_angle(lines[i], lines[j]):</span><br><span class="line">                <span class="keyword">return</span> (lines[i], lines[j])</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_intersection</span>(<span class="params">line1, line2</span>):</span></span><br><span class="line">    <span class="comment"># 计算两条线的交点</span></span><br><span class="line">    a1 = line1.y2() - line1.y1()</span><br><span class="line">    b1 = line1.x1() - line1.x2()</span><br><span class="line">    c1 = line1.x2()*line1.y1() - line1.x1()*line1.y2()</span><br><span class="line"></span><br><span class="line">    a2 = line2.y2() - line2.y1()</span><br><span class="line">    b2 = line2.x1() - line2.x2()</span><br><span class="line">    c2 = line2.x2() * line2.y1() - line2.x1()*line2.y2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1 * b2 - a2 * b1) != <span class="number">0</span> <span class="keyword">and</span> (a2 * b1 - a1 * b2) != <span class="number">0</span>:</span><br><span class="line">        cross_x = int((b1*c2-b2*c1)/(a1*b2-a2*b1))</span><br><span class="line">        cross_y = int((c1*a2-c2*a1)/(a1*b2-a2*b1))</span><br><span class="line">        <span class="keyword">return</span> (cross_x, cross_y)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_cross_point</span>(<span class="params">cross_x, cross_y</span>):</span></span><br><span class="line">    img.draw_cross(cross_x, cross_y)</span><br><span class="line">    img.draw_circle(cross_x, cross_y, <span class="number">5</span>)</span><br><span class="line">    img.draw_circle(cross_x, cross_y, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># All lines also have `x1()`, `y1()`, `x2()`, and `y2()` methods to get their end-points</span></span><br><span class="line"><span class="comment"># and a `line()` method to get all the above as one 4 value tuple for `draw_line()`.</span></span><br><span class="line"></span><br><span class="line">old_cross_x = <span class="number">0</span></span><br><span class="line">old_cross_y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#threshold</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    img.binary(binary_threshold)</span><br><span class="line">    img.gaussian(<span class="number">5</span>)</span><br><span class="line">    img.gaussian(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除摄像头畸变， 这里我们采用的是13.8mm的，近距离没有畸变效果</span></span><br><span class="line">    <span class="comment"># if enable_lens_corr: img.lens_corr(1.8) # for 2.8mm lens...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># `threshold` controls how many lines in the image are found. Only lines with</span></span><br><span class="line">    <span class="comment"># edge difference magnitude sums greater than `threshold` are detected...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># More about `threshold` - each pixel in the image contributes a magnitude value</span></span><br><span class="line">    <span class="comment"># to a line. The sum of all contributions is the magintude for that line. Then</span></span><br><span class="line">    <span class="comment"># when lines are merged their magnitudes are added togheter. Note that `threshold`</span></span><br><span class="line">    <span class="comment"># filters out lines with low magnitudes before merging. To see the magnitude of</span></span><br><span class="line">    <span class="comment"># un-merged lines set `theta_margin` and `rho_margin` to 0...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># `theta_margin` and `rho_margin` control merging similar lines. If two lines</span></span><br><span class="line">    <span class="comment"># theta and rho value differences are less than the margins then they are merged.</span></span><br><span class="line"></span><br><span class="line">    lines =  img.find_lines(threshold = <span class="number">2000</span>, theta_margin = <span class="number">40</span>, rho_margin = <span class="number">20</span>, roi=(<span class="number">5</span>, <span class="number">5</span>, <span class="number">150</span>,<span class="number">110</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">       <span class="comment"># img.draw_line(line.line(), color = (255, 0, 0))</span></span><br><span class="line">    <span class="comment"># 如果画面中有两条直线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(lines) &gt;= <span class="number">2</span>:</span><br><span class="line">        (line1, line2) = find_verticle_lines(lines)</span><br><span class="line">        <span class="keyword">if</span> (line1 == <span class="literal">None</span> <span class="keyword">or</span> line2 == <span class="literal">None</span>):</span><br><span class="line">            <span class="comment"># 没有垂直的直线</span></span><br><span class="line">            draw_cross_point(old_cross_x, old_cross_y)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 画线</span></span><br><span class="line">        <span class="comment"># img.draw_line(line1.line(), color = (255, 0, 0))</span></span><br><span class="line">        <span class="comment"># img.draw_line(line2.line(), color = (255, 0, 0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算交点</span></span><br><span class="line">        (cross_x, cross_y) = calculate_intersection(line1, line2)</span><br><span class="line">        print(<span class="string">&quot;cross_x:  %d, cross_y: %d&quot;</span>%(old_cross_x, old_cross_y))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cross_x != <span class="number">-1</span> <span class="keyword">and</span> cross_y != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> abs(cross_x - old_cross_x) &lt; move_threshold <span class="keyword">and</span> abs(cross_y - old_cross_y) &lt; move_threshold:</span><br><span class="line">                <span class="comment"># 小于移动阈值， 不移动</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                old_cross_x = int(old_cross_x * (<span class="number">1</span> - forget_ratio) + cross_x * forget_ratio)</span><br><span class="line">                old_cross_y = int(old_cross_y * (<span class="number">1</span> - forget_ratio) + cross_y * forget_ratio)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        draw_cross_point(old_cross_x, old_cross_y)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;FPS %f&quot;</span> % clock.fps())</span><br><span class="line"></span><br><span class="line"><span class="comment"># About negative rho values:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A [theta+0:-rho] tuple is the same as [theta+180:+rho].</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>PS</strong>:<br>源代码链接<a href="http://makermare.com:60010/example/feature/right-angle-detection.html">http://makermare.com:60010/example/feature/right-angle-detection.html</a></p><h3 id="方法二（改进）：利用OpenMV视野中像素值的突变寻找直角等特征"><a href="#方法二（改进）：利用OpenMV视野中像素值的突变寻找直角等特征" class="headerlink" title="方法二（改进）：利用OpenMV视野中像素值的突变寻找直角等特征"></a>方法二（改进）：利用OpenMV视野中像素值的突变寻找直角等特征</h3><p>因为方法一寻找直角交点的缺陷性，经过我们的讨论，认为也可以计算图像区域中目标物体所占的总像素的多少，从而区分直线和直角。  </p><p>直角和直线出现在OpenMV视野区域中的时候，两者的像素会有较大的差异，通过合理地调节阈值，可以将直线和直角区分开来。（经过大致测算，使用此方法直角和直线的总像素个数大约相差一倍左右）。</p><p>这里先贴上自己写的部分程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"><span class="keyword">from</span> pyb <span class="keyword">import</span> LED</span><br><span class="line"><span class="keyword">from</span> pyb <span class="keyword">import</span> UART,Timer</span><br><span class="line"></span><br><span class="line">uart = UART(<span class="number">3</span>,<span class="number">115200</span>)<span class="comment">#初始化串口 波特率 115200</span></span><br><span class="line">sensor.reset()</span><br><span class="line"><span class="comment">#sensor.set_vflip(True)</span></span><br><span class="line"><span class="comment">#sensor.set_hmirror(True)</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QQQVGA) <span class="comment"># 80x60 (4,800 pixels) - O(N^2) max = 2,3040,000.</span></span><br><span class="line"><span class="comment">#sensor.set_windowing([0,20,80,40])</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)     <span class="comment"># WARNING: If you use QQVGA it may take seconds</span></span><br><span class="line">clock = time.clock()                <span class="comment"># to process a frame sometimes.</span></span><br><span class="line"></span><br><span class="line">x_width = <span class="number">80</span></span><br><span class="line">y_height = <span class="number">60</span>    <span class="comment"># 图像是QQQVGA,则图像是80x60的分辨率</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleline_check</span>():</span></span><br><span class="line">    flager = <span class="number">0</span></span><br><span class="line">    rho_err = <span class="number">0</span></span><br><span class="line">    theta_err = <span class="number">0</span></span><br><span class="line">    is_verticle = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">singleline_check = singleline_check()</span><br><span class="line"></span><br><span class="line">BINARY_THRESHOLD = (<span class="number">30</span>, <span class="number">120</span>)  <span class="comment">#二值化阈值</span></span><br><span class="line"></span><br><span class="line">verticle_pixels_threshold = [<span class="number">200</span>, <span class="number">300</span>]   <span class="comment">#像素最大和最小阈值</span></span><br><span class="line">track_line_threshold = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_pixels_with_movement</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="keyword">global</span> x_width, y_height</span><br><span class="line"></span><br><span class="line">    x_pos = <span class="number">0</span></span><br><span class="line">    y_pos = <span class="number">0</span></span><br><span class="line">    total_white_pixels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_pos <span class="keyword">in</span> range(x_width):</span><br><span class="line">        <span class="keyword">for</span> y_pos <span class="keyword">in</span> range(y_height):</span><br><span class="line">            <span class="keyword">if</span> img.get_pixel(x_pos, y_pos) == <span class="number">255</span>:</span><br><span class="line">                total_white_pixels += <span class="number">1</span>  <span class="comment"># 利用get_pixel()方法，计算当前图像中白色色块所占的像素大小</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;total white pixels are&quot;</span>, total_white_pixels)</span><br><span class="line">    <span class="keyword">if</span> total_white_pixels &gt;= verticle_pixels_threshold[<span class="number">0</span>] <span class="keyword">and</span> total_white_pixels &lt;= verticle_pixels_threshold[<span class="number">1</span>]:</span><br><span class="line">        singleline_check.is_verticle = <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> total_white_pixels &gt;= track_line_threshold[<span class="number">0</span>] <span class="keyword">and</span> total_white_pixels &lt;= track_line_threshold[<span class="number">1</span>]:</span><br><span class="line">        singleline_check.is_verticle = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        singleline_check.is_verticle = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;is verticle flag:&quot;</span>, singleline_check.is_verticle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    img = sensor.snapshot().binary([BINARY_THRESHOLD]).erode(<span class="number">1</span>)</span><br><span class="line">    count_pixels_with_movement(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 之后打包发送数据给飞控，这里略...</span></span><br></pre></td></tr></table></figure><p>程序中，<code>count_pixels_with_movement(img)</code>用于计算此时视野范围中二值化后的白色目标色块所占的总像素的个数。只要每一个像素阈值（如<code>verticle_pixels_threshold</code>和<code>track_line_threshold</code>）设置得恰到，运用此方法，可以较为准确地区分并识别出前方有直角，并会回馈一个标志位<code>singleline_check.is_verticle = 2</code>给飞控，使其做出直角判断并转弯。程序实测帧率在30-40左右，能够基本满足要求。</p><h2 id="识别特征信息（可以用于识别飞机起飞降落点）"><a href="#识别特征信息（可以用于识别飞机起飞降落点）" class="headerlink" title="识别特征信息（可以用于识别飞机起飞降落点）"></a>识别特征信息（可以用于识别飞机起飞降落点）</h2><h3 id="数字识别"><a href="#数字识别" class="headerlink" title="数字识别"></a>数字识别</h3><p>按照例程，好像可以使用方法<code>img.find_number()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LetNet Example</span></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()                      <span class="comment"># Reset and initialize the sensor.</span></span><br><span class="line">sensor.set_contrast(<span class="number">3</span>)</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE) <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA)   <span class="comment"># Set frame size to QVGA (320x240)</span></span><br><span class="line">sensor.set_windowing((<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line"></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)     <span class="comment"># Wait for settings take effect.</span></span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>)</span><br><span class="line">sensor.set_auto_exposure(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()                <span class="comment"># Create a clock object to track the FPS.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()                    <span class="comment"># Update the FPS clock.</span></span><br><span class="line">    img = sensor.snapshot()         <span class="comment"># Take a picture and return the image.</span></span><br><span class="line">    out = img.invert().find_number()</span><br><span class="line">    <span class="keyword">if</span> out[<span class="number">1</span>] &gt; <span class="number">3.0</span>:</span><br><span class="line">        print(out[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#print(clock.fps())             # Note: OpenMV Cam runs about half as fast when connected</span></span><br><span class="line">                                    <span class="comment"># to the IDE. The FPS should increase once disconnected.</span></span><br></pre></td></tr></table></figure><p><strong>PS</strong>:</p><ol><li><p>来源于<a href="http://makermare.com:60010/example/feature/digital-recognition.html">http://makermare.com:60010/example/feature/digital-recognition.html</a></p></li><li><p>好像因为新版本的固件不支持识别<code>数字</code>的方法<code>img.find_number()</code>了，我的是OpenMV 4,自己试了试好像会报错，不知道为啥，应该是官方文档说的这个原因：</p></li></ol><p>IDE报错：<br><img src="https://i.loli.net/2019/08/02/5d43bdc4b9dd663760.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/02/5d43bdc4b9dd663760.png" srcset="data:image/png;base64,666" alt="IDE报错"><br>官方文档解释：<br><img src="https://i.loli.net/2019/08/02/5d43bede5e23724343.png" class="lazyload" data-srcset="https://i.loli.net/2019/08/02/5d43bede5e23724343.png" srcset="data:image/png;base64,666" alt="官方文档解释"></p><hr><h3 id="关键点识别"><a href="#关键点识别" class="headerlink" title="关键点识别"></a>关键点识别</h3><p>无可奈何，好像暂时就只能使用寻找<code>关键点</code>的方法了.<br>当需要识别特征信息的时候，可以使用官方自带的一个方法<code>img.find_keypoints()</code>，keypoints即关键点，当识别到物块的关键点后，保存到变量<code>kpts2</code>中，便可以进行匹配，即运用<code>image.match_descriptor()</code>方法，进行匹配度识别，若匹配到了，便可以在图像上画出特征点，运用方法<code>img.draw_keypoints()</code>。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用特征点检测特定物体例程。</span></span><br><span class="line"><span class="comment"># 向相机显示一个对象，然后运行该脚本。 一组关键点将被提取一次，然后</span></span><br><span class="line"><span class="comment"># 在以下帧中进行跟踪。 如果您想要一组新的关键点，请重新运行该脚本。</span></span><br><span class="line"><span class="comment"># 注意：请参阅文档以调整find_keypoints和match_keypoints。</span></span><br><span class="line"><span class="keyword">import</span> sensor, time, image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset sensor</span></span><br><span class="line">sensor.reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sensor settings</span></span><br><span class="line">sensor.set_contrast(<span class="number">3</span>)</span><br><span class="line">sensor.set_gainceiling(<span class="number">16</span>)</span><br><span class="line">sensor.set_framesize(sensor.VGA)</span><br><span class="line">sensor.set_windowing((<span class="number">320</span>, <span class="number">240</span>))</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)</span><br><span class="line"></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>, value=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出特征点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_keypoints</span>(<span class="params">img, kpts</span>):</span></span><br><span class="line">    <span class="keyword">if</span> kpts:</span><br><span class="line">        print(kpts)</span><br><span class="line">        img.draw_keypoints(kpts)</span><br><span class="line">        img = sensor.snapshot()</span><br><span class="line">        time.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">kpts1 = <span class="literal">None</span></span><br><span class="line"><span class="comment">#kpts1保存目标物体的特征，可以从文件导入特征，但是不建议这么做。</span></span><br><span class="line"><span class="comment">#kpts1 = image.load_descriptor(&quot;/desc.orb&quot;)</span></span><br><span class="line"><span class="comment">#img = sensor.snapshot()</span></span><br><span class="line"><span class="comment">#draw_keypoints(img, kpts1)</span></span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    <span class="keyword">if</span> (kpts1 == <span class="literal">None</span>):</span><br><span class="line">        <span class="comment">#如果是刚开始运行程序，提取最开始的图像作为目标物体特征，kpts1保存目标物体的特征</span></span><br><span class="line">        <span class="comment">#默认会匹配目标特征的多种比例大小，而不仅仅是保存目标特征时的大小，比模版匹配灵活。</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> By default find_keypoints returns multi-scale keypoints extracted from an image pyramid.</span></span><br><span class="line">        kpts1 = img.find_keypoints(max_keypoints=<span class="number">150</span>, threshold=<span class="number">10</span>, scale_factor=<span class="number">1.2</span>)</span><br><span class="line">        <span class="comment">#image.find_keypoints(roi=Auto, threshold=20, normalized=False, scale_factor=1.5, max_keypoints=100, corner_detector=CORNER_AGAST)</span></span><br><span class="line">        <span class="comment">#roi表示识别的区域，是一个元组（x,y,w,h）,默认与framsesize大小一致。</span></span><br><span class="line">        <span class="comment">#threshold是0~255的一个阈值，用来控制特征点检测的角点数量。用默认的AGAST特征点检测，这个阈值大概是20。用FAST特征点检测，这个阈值大概是60～80。阈值越低，获得的角点越多。</span></span><br><span class="line">        <span class="comment">#normalized是一个布尔数值，默认是False，可以匹配目标特征的多种大小（比ncc模版匹配效果灵活）。如果设置为True，关闭特征点检测的多比例结果，仅匹配目标特征的一种大小（类似于模版匹配），但是运算速度会更快一些。</span></span><br><span class="line">        <span class="comment">#scale_factor是一个大于1.0的浮点数。这个数值越高，检测速度越快，但是匹配准确率会下降。一般在1.35~1.5左右最佳。</span></span><br><span class="line">        <span class="comment">#max_keypoints是一个物体可提取的特征点的最大数量。如果一个物体的特征点太多导致RAM内存爆掉，减小这个数值。</span></span><br><span class="line">        <span class="comment">#corner_detector是特征点检测采取的算法，默认是AGAST算法。FAST算法会更快但是准确率会下降。</span></span><br><span class="line">        draw_keypoints(img, kpts1)</span><br><span class="line">        <span class="comment">#画出此时的目标特征</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#当与最开始的目标特征进行匹配时，默认设置normalized=True，只匹配目标特征的一种大小。</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> When extracting keypoints to match the first descriptor, we use normalized=True to extract</span></span><br><span class="line">        <span class="comment"># keypoints from the first scale only, which will match one of the scales in the first descriptor.</span></span><br><span class="line">        kpts2 = img.find_keypoints(max_keypoints=<span class="number">150</span>, threshold=<span class="number">10</span>, normalized=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment">#如果检测到特征物体</span></span><br><span class="line">        <span class="keyword">if</span> (kpts2):</span><br><span class="line">            <span class="comment">#匹配当前找到的特征和最初的目标特征的相似度</span></span><br><span class="line">            match = image.match_descriptor(kpts1, kpts2, threshold=<span class="number">85</span>)</span><br><span class="line">            <span class="comment">#image.match_descriptor(descritor0, descriptor1, threshold=70, filter_outliers=False)。本函数返回kptmatch对象。</span></span><br><span class="line">            <span class="comment">#threshold阈值设置匹配的准确度，用来过滤掉有歧义的匹配。这个值越小，准确度越高。阈值范围0～100，默认70</span></span><br><span class="line">            <span class="comment">#filter_outliers默认关闭。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#match.count()是kpt1和kpt2的匹配的近似特征点数目。</span></span><br><span class="line">            <span class="comment">#如果大于10，证明两个特征相似，匹配成功。</span></span><br><span class="line">            <span class="keyword">if</span> (match.count()&gt;<span class="number">10</span>):</span><br><span class="line">                <span class="comment"># If we have at least n &quot;good matches&quot;</span></span><br><span class="line">                <span class="comment"># Draw bounding rectangle and cross.</span></span><br><span class="line">                <span class="comment">#在匹配到的目标特征中心画十字和矩形框。</span></span><br><span class="line">                img.draw_rectangle(match.rect())</span><br><span class="line">                img.draw_cross(match.cx(), match.cy(), size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#match.theta()是匹配到的特征物体相对目标物体的旋转角度。</span></span><br><span class="line">            print(kpts2, <span class="string">&quot;matched:%d dt:%d&quot;</span>%(match.count(), match.theta()))</span><br><span class="line">            <span class="comment">#不建议draw_keypoints画出特征角点。</span></span><br><span class="line">            <span class="comment"># <span class="doctag">NOTE:</span> uncomment if you want to draw the keypoints</span></span><br><span class="line">            <span class="comment">#img.draw_keypoints(kpts2, size=KEYPOINTS_SIZE, matched=True)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Draw FPS</span></span><br><span class="line">    <span class="comment">#打印帧率。</span></span><br><span class="line">    img.draw_string(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;FPS:%.2f&quot;</span>%(clock.fps()))</span><br></pre></td></tr></table></figure><p><strong>PS</strong>:<br>来源于星瞳科技例程<a href="https://book.openmv.cc/example/09-Feature-Detection/keypoints.html">https://book.openmv.cc/example/09-Feature-Detection/keypoints.html</a></p><p>这个例程还需要完善，运用到具体的OpenMV代码中需要将函数再次封装和修改。</p><h2 id="识别二维码（QR-Code）、条形码（Barcode）和标记（AprilTag）"><a href="#识别二维码（QR-Code）、条形码（Barcode）和标记（AprilTag）" class="headerlink" title="识别二维码（QR Code）、条形码（Barcode）和标记（AprilTag）"></a>识别二维码（QR Code）、条形码（Barcode）和标记（AprilTag）</h2><p>对于二维码和条形码，相对来说较为简单，其核心语句就只有一句，分别为：</p><ul><li>img.find_qrcodes()   寻找二维码信息<br>例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)</span><br><span class="line">sensor.set_framesize(sensor.VGA)</span><br><span class="line">sensor.set_windowing((<span class="number">240</span>, <span class="number">240</span>)) <span class="comment"># look at center 240x240 pixels of the VGA resolution.</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>) <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> img.find_qrcodes():</span><br><span class="line">        print(code)</span><br><span class="line">    print(clock.fps())</span><br></pre></td></tr></table></figure><ul><li>img.find_barcodes()    寻找条形码信息<br>例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, math</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)</span><br><span class="line">sensor.set_framesize(sensor.VGA) <span class="comment"># High Res!</span></span><br><span class="line">sensor.set_windowing((<span class="number">640</span>, <span class="number">80</span>)) <span class="comment"># V Res of 80 == less work (40 for 2X the speed).</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>)  <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">sensor.set_auto_whitebal(<span class="literal">False</span>)  <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条形码检测可以在OpenMV Cam的OV7725相机模块的640x480分辨率下运行。</span></span><br><span class="line"><span class="comment"># 条码检测也将在RGB565模式下工作，但分辨率较低。 也就是说，</span></span><br><span class="line"><span class="comment"># 条形码检测需要更高的分辨率才能正常工作，因此应始终以640x480的灰度运行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">barcode_name</span>(<span class="params">code</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.EAN2):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EAN2&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.EAN5):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EAN5&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.EAN8):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EAN8&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.UPCE):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UPCE&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.ISBN10):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ISBN10&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.UPCA):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UPCA&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.EAN13):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EAN13&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.ISBN13):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ISBN13&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.I25):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I25&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.DATABAR):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DATABAR&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.DATABAR_EXP):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DATABAR_EXP&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.CODABAR):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CODABAR&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.CODE39):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CODE39&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.PDF417):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PDF417&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.CODE93):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CODE93&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(code.type() == image.CODE128):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CODE128&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    codes = img.find_barcodes()</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> codes:</span><br><span class="line">        img.draw_rectangle(code.rect())</span><br><span class="line">        print_args = (barcode_name(code), code.payload(), (<span class="number">180</span> * code.rotation()) / math.pi, code.quality(), clock.fps())</span><br><span class="line">        print(<span class="string">&quot;Barcode %s, Payload \&quot;%s\&quot;, rotation %f (degrees), quality %d, FPS %f&quot;</span> % print_args)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> codes:</span><br><span class="line">        print(<span class="string">&quot;FPS %f&quot;</span> % clock.fps())</span><br></pre></td></tr></table></figure><ul><li>img.find_apriltags()    寻找标记信息<br>例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, math</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.VGA) <span class="comment"># we run out of memory if the resolution is much bigger...</span></span><br><span class="line">sensor.set_windowing((<span class="number">160</span>, <span class="number">120</span>)) <span class="comment"># Look at center 160x120 pixels of the VGA resolution.</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>)  <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">sensor.set_auto_whitebal(<span class="literal">False</span>)  <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意！与find_qrcodes不同，find_apriltags方法不需要对镜像进行镜头校正。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标签系列有什么区别？ 那么，例如，TAG16H5家族实际上是一个4x4的方形标签。 </span></span><br><span class="line"><span class="comment">#所以，这意味着可以看到比6x6的TAG36H11标签更长的距离。 然而，较低的H值（H5对H11）</span></span><br><span class="line"><span class="comment">#意味着4x4标签的假阳性率远高于6x6标签。 所以，除非你有理由使用其他标签系列，</span></span><br><span class="line"><span class="comment">#否则使用默认族TAG36H11。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> img.find_apriltags(): <span class="comment"># defaults to TAG36H11</span></span><br><span class="line">        img.draw_rectangle(tag.rect(), color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        img.draw_cross(tag.cx(), tag.cy(), color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">        print_args = (tag.id(), (<span class="number">180</span> * tag.rotation()) / math.pi)</span><br><span class="line">        print(<span class="string">&quot;Tag Family TAG36H11, Tag ID %d, rotation %f (degrees)&quot;</span> % print_args)</span><br><span class="line">    print(clock.fps())</span><br></pre></td></tr></table></figure><h1 id="另附–我们组的飞机方案"><a href="#另附–我们组的飞机方案" class="headerlink" title="另附–我们组的飞机方案"></a>另附–我们组的飞机方案</h1><p>最近，我们组在紧张地准备电赛测控四旋翼无人机的题目，在准备过程中，我们购买了无名创新的TM4C123的飞控，正在研究源码和视觉模块的运用。<br>无名创新的飞控是开源的，在B站上面有对应的讲解视频，涉及操作类和代码讲解类的视频，下面附上其网址：  </p><p>无名科创开源飞控QQ群：540707961<br><a href="https://blog.csdn.net/u011992534">CSDN博客</a><br>优酷ID：NamelessCotrun无名小哥<br><a href="https://space.bilibili.com/67803559/#/video">B站教学视频</a><br><a href="https://shop348646912.taobao.com/?spm=2013.1.1000126.2.5ce78a88ht1sO2">淘宝店铺</a><br>百度贴吧:无名科创开源飞控<br><a href="https://www.nameless.tech/">公司官网</a>  </p><p>我们组在学习的过程中，按照老师给的建议，决定采用外加一个TM4C123的控制板作为模拟的遥控器（即脱掉遥控器自主飞行降落），其中，无名的飞控是采用PPM信号编码和解码的方式，为了模仿遥控器的信号，我们参考了网上的一些文档，觉得十分有用：</p><h2 id="PPM原理和代码"><a href="#PPM原理和代码" class="headerlink" title="PPM原理和代码"></a>PPM原理和代码</h2><p><a href="https://blog.csdn.net/Aaron_Suen/article/details/79416477">https://blog.csdn.net/Aaron_Suen/article/details/79416477</a><br><a href="https://blog.csdn.net/yibu_refresh/article/details/45752131">https://blog.csdn.net/yibu_refresh/article/details/45752131</a>  </p><p>这几天我们队进度有点卡顿了，正在向两方面进展。<br>我们准备了两个方案：<br><strong>使用之前所说的外置模拟遥控器的方式</strong><br><strong>使用无名飞控自带的SDK模式进行二次开发</strong></p><hr><p>感谢你的耐心阅读呀(๑<em>◡</em>๑)，原创总结不易，收藏并评论一下呗~</p><p>你的支持就是我前进的动力呀~</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
            <tag> OpenMV </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好鸭~</title>
      <link href="archives/f2d5fff6.html"/>
      <url>archives/f2d5fff6.html</url>
      
        <content type="html"><![CDATA[<p>你好！这里是Sublime的个人小屋哦ヾ(◍°∇°◍)ﾉﾞ<br>从今天起，我准备开始写博客啦<del>~</del><br>希望大家支持我呀^_^</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world, hello my blog!&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world, hello my blog!&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span><span class="string">&quot;hello world, hello my blog!&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;hello world, hello my blog!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello world, hello my blog!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MsgBox<span class="string">&quot;hello world, hello my blog!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;hello world, hello my blog!&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span><span class="string">&#x27;hello world, hello my blog!&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello world, hello my blog!&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Console.WriteLine(<span class="string">&quot;hello world, hello my blog!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>hello world, hello my blog!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Have a GOOD TIME!<br>你的鼓励就是我前进的动力呐~<br>(◕ᴗ◕✿)</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
