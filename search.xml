<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019电赛准备阶段学习总结]]></title>
    <url>%2Farchives%2Ff10b0e1a.html</url>
    <content type="text"><![CDATA[第二年参加电赛了，今年来到测控无人机方向，主要记录一些学习经历。再苦逼也要加油呀！！！ 2019.7.18更新最近，我们组在紧张地准备电赛测控四旋翼无人机的题目，在准备过程中，我们购买了无名创新的TM4C123的飞控，正在研究源码和视觉模块的运用。无名创新的飞控是开源的，在B站上面有对应的讲解视频，涉及操作类和代码讲解类的视频，下面附上其网址： 无名科创开源飞控QQ群：540707961CSDN博客优酷ID：NamelessCotrun无名小哥B站教学视频客户使用心得、改进意见征集贴淘宝店铺百度贴吧:无名科创开源飞控公司官网 我们组在学习的过程中，按照老师给的建议，决定采用外加一个TM4C123的控制板作为模拟的遥控器（即脱掉遥控器自主飞行降落），其中，无名的飞控是采用PPM信号编码和解码的方式，为了模仿遥控器的信号，我们参考了网上的一些文档，觉得十分有用： PPM原理和代码https://blog.csdn.net/Aaron_Suen/article/details/79416477https://blog.csdn.net/yibu_refresh/article/details/45752131 2019.7.26更新这几天我们队进度有点卡顿了，正在向两方面进展。我们准备了两个方案：使用之前所说的外置模拟遥控器的方式使用无名飞控自带的SDK模式进行二次开发 与此时同，我开始研究OpenMV视觉模块，OpenMV是基于嵌入式STM32单片机的基础上，经过层层封装之后，运用microPython语法开发的模块。（我们用的是OpenMV mini板） OpenMV寻找直角由于电赛视觉模块寻迹的原因，可能会涉及无人机直角转弯的问题，通过查找网上资料，获得了如下Python代码,感觉有一定的参考价值： 通过这个程序，我发现可以调用calculate_angle(line1, line2)函数得出偏角值，调用calculate_intersection(line1, line2)函数得出当前x和y的坐标值(cross_x, cross_y)，这样，再通过串口将对应的数据帧发送给飞控，在飞控端再进行帧格式解析，得出对应的数据后，在进行飞机相应的姿态调整。 123456def calculate_angle(line1, line2): # 利用四边形的角公式， 计算出直线夹角 angle = (180 - abs(line1.theta() - line2.theta())) if angle > 90: angle = 180 - angle return angle 123456789101112131415def calculate_intersection(line1, line2): # 计算两条线的交点 a1 = line1.y2() - line1.y1() b1 = line1.x1() - line1.x2() c1 = line1.x2()*line1.y1() - line1.x1()*line1.y2() a2 = line2.y2() - line2.y1() b2 = line2.x1() - line2.x2() c2 = line2.x2() * line2.y1() - line2.x1()*line2.y2() if (a1 * b2 - a2 * b1) != 0 and (a2 * b1 - a1 * b2) != 0: cross_x = int((b1*c2-b2*c1)/(a1*b2-a2*b1)) cross_y = int((c1*a2-c2*a1)/(a1*b2-a2*b1)) return (cross_x, cross_y) return (-1, -1) 下面附上完整源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145# Find Lines Example## This example shows off how to find lines in the image. For each line object# found in the image a line object is returned which includes the line's rotation.# Note: Line detection is done by using the Hough Transform:# http://en.wikipedia.org/wiki/Hough_transform# Please read about it above for more information on what `theta` and `rho` are.# find_lines() finds infinite length lines. Use find_line_segments() to find non-infinite lines.enable_lens_corr = False # turn on for straighter lines...import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.GRAYSCALE) # grayscale is fastersensor.set_framesize(sensor.QQVGA)sensor.skip_frames(time = 2000)clock = time.clock()# min_degree = 0 # 直线最小角度# max_degree = 179 # 直线最大角度# 判断是否为直角的阈值right_angle_threshold = (70, 90)binary_threshold = [(0, 60)]forget_ratio = 0.8move_threshold = 5def calculate_angle(line1, line2): # 利用四边形的角公式， 计算出直线夹角 angle = (180 - abs(line1.theta() - line2.theta())) if angle > 90: angle = 180 - angle return angledef is_right_angle(line1, line2): global right_angle_threshold # 判断两个直线之间的夹角是否为直角 angle = calculate_angle(line1, line2) if angle >= right_angle_threshold[0] and angle = 2: (line1, line2) = find_verticle_lines(lines) if (line1 == None or line2 == None): # 没有垂直的直线 draw_cross_point(old_cross_x, old_cross_y) continue # 画线 # img.draw_line(line1.line(), color = (255, 0, 0)) # img.draw_line(line2.line(), color = (255, 0, 0)) # 计算交点 (cross_x, cross_y) = calculate_intersection(line1, line2) print("cross_x: %d, cross_y: %d"%(old_cross_x, old_cross_y)) if cross_x != -1 and cross_y != -1: if abs(cross_x - old_cross_x) < move_threshold and abs(cross_y - old_cross_y) < move_threshold: # 小于移动阈值， 不移动 pass else: old_cross_x = int(old_cross_x * (1 - forget_ratio) + cross_x * forget_ratio) old_cross_y = int(old_cross_y * (1 - forget_ratio) + cross_y * forget_ratio) draw_cross_point(old_cross_x, old_cross_y) print("FPS %f" % clock.fps())# About negative rho values:## A [theta+0:-rho] tuple is the same as [theta+180:+rho]. 这里附上源代码链接。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>电赛</tag>
        <tag>OpenMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好鸭~]]></title>
    <url>%2Farchives%2Ff2d5fff6.html</url>
    <content type="text"><![CDATA[你好！这里是Sublime的个人小屋哦ヾ(◍°∇°◍)ﾉﾞ从今天起，我准备开始写博客啦~希望大家支持我呀^_^ 1printf("hello world, hello my blog!"); 1cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
</search>
